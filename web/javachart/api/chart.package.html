<HTML>
<HEAD>
   <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
   <META NAME="GENERATOR" CONTENT="Mozilla/4.03 [en] (X11; I; AIX 4.1) [Netscape]">
   <TITLE>Chart Package Overview</TITLE>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000ED" VLINK="#551A8A" ALINK="#FE0000">

<CENTER>[<A HREF="index.html">Index</A>] [<A HREF="introduction.html">Introduction</A>]
[<A HREF="installation.html">Installation</A>] [<A HREF="chart.component.html">Component</A>]
[<A HREF="complete.chart.html">Chart</A>] [<A HREF="axis.system.html">Axis</A>]
[<A HREF="utility.html">Utility</A>] [<A HREF="applet.html">Applet</A>]
[<A HREF="Appendix.A.html">Appendix A</A>] [<A HREF="Appendix.B.html">Appendix
B</A>] [<A HREF="Appendix.C.html">Appendix C</A>] [<A HREF="Appendix.D.html">Appendix
D</A>] [<A HREF="packages.html">API</A>]</CENTER>

<HR WIDTH="100%">
<H1>
<FONT COLOR="#008B8B">Chart Package Overview</FONT></H1>

<H4>
<A NAME="Overall"></A><FONT COLOR="#9400D3">Overall Organization</FONT></H4>
JavaChart comprises a set of reusable software components that are combined
to form complete charts. These components are stored in individual classes
that may be standalone classes or extensions of other classes. Significantly,
the classes can be recombined in new ways to form new chart types, or they
can be extended to leverage pre-existing functionality.

<P>Visual Engineering provides a set of pre-constructed complete charts
that combine these components in a uniform way. These chart classes are
uniformly named [chart-type]Chart.class; e.g. BarChart.class AreaChart.class,
LineChart.class and so on. They also all extend the Chart abstract superclass,
which provides functionality common to all charts, such as adding datasets,
installing a background, and so on.

<P>Generally, one of the preconstructed Charts will meet your needs. We
have provided source code for each of these specific Chart subclasses so
you can see how to create your own combinations.

<P>Every chart includes one or more <A HREF="javachart.chart.Dataset.html">Dataset</A>
classes, a <A HREF="javachart.chart.Background.html">Background</A> and
a <A HREF="javachart.chart.Plotarea.html">Plotarea</A> class, and a few
other necessary utility classes. Each chart also contains one or more graphical
components, such as a Line class (responsible for rendering an array of
Dataset classes in a line chart form) or a Pie class (responsible for rendering
a Dataset class in pie chart form).

<P>Many component classes are dependent on other components. For example,
an Axis class requires an array of Dataset classes and a Plotarea class
so that it may scale properly and draw itself in the correct location.
The Chart abstract class and the specific chart type classes combine these
components in a coherent fashion.

<P>Subclassing is used extensively to share common functionality in JavaChart.
For example, Axis is a superclass to LabelAxis, DateAxis, and SpeedoAxis.
All these subclasses re-use significant portions of Axis's functionality,
and inherit most of their properties from the Axis superclass.

<P>JavaChart also uses Java interfaces in a few strategic places to enhance
the package's flexibility and to facilitate JavaChart use within an application's
GUI. JavaChart includes interfaces for Axis, Legend, and Chart classes.
Should you choose to extend JavaChart classes for your own use, we recommend
implementing these interfaces for continuing compatibility.

<P>
<HR WIDTH="100%">
<H4>
<A NAME="Properties"></A><FONT COLOR="#9400D3">Properties</FONT></H4>
Internally, JavaChart classes each rely on a set of properties to define
the look or behavior of a particular class. A programmer can gain access
to these properties in a variety of ways.

<P>Generally, programmers will use the access methods available for each
class to manipulate a class' properties. These access methods are uniform
throughout JavaChart, using signatures recognized by Java 1.1's introspection
facility. A sample access method pair from our Axis class is as follows:
<UL><TT>public int getLabelAngle();</TT>

<P><TT>public void setLabelAngle(int angle);</TT></UL>
To change the label angle for a particular chart's Y axis to 90 degrees,
then, you'd use something like this:
<UL><TT>myChart.getYAxis().setLabelAngle(90);</TT></UL>
The properties of a particular class also include that class' companion
classes, e.g. an Axis' Dataset classes. You can manipulate these properties
in the same fashion you would manipulate simple class properties. For example,
you might use something like this to cause JavaChart to scale a Y axis
for theoretical data instead of actual data:
<UL><TT>savedDatasets = myChart.getYAxis().getDatasets();</TT>

<P><TT>myChart.getYAxis().setDatasets(theoreticalDatasets);</TT>

<P><TT>myChart.getYAxis().scale();</TT>

<P><TT>myChart.getYAxis.setDatasets(savedDatasets);</TT></UL>
Properties are initialized to reasonable default values, so that a simple
chart probably doesn't need to change too many properties. However, an
extensive set of properties lets you easily create a signature look for
your application's charts.

<P>The JavaChart applet collection uses HTML parameters to set most chart
properties. This is a simple way to initialize a wide range of chart properties
if your application or applet can use JavaChart's preconstructed applet
classes. Since we also provide the applet source code, you can also transfer
portions of the applet source code into your own applets to set these properties.

<P>Many of the properties you'll be most interested setting come from JavaChart's
<A HREF="javachart.chart.Gc.html">Gc class</A>. This is a utility class
that stores values for graphical attributes like colors and images. Almost
every JavaChart class has at least one Gc associated with it. You will
quickly come to appeciate this uniformity in you own code, as you can develop
uniform ways to deal with all sorts of graphical attributes. Here are a
couple of examples of using the Gc class:
<UL><TT>myChart.getBackground().getGc().setFillColor(Color.red);</TT>

<P><TT>myChart.getPlotArea().getGc().setFillColor(Color.blue);</TT>

<P><TT>myChart.getAxis.getGridGc().setLineColor(Color.blue);</TT></UL>
Note that because of the way Java passes values by reference, you can also
group property setting functions together:
<UL><TT>myGc = myChart.getBackground.getGc();</TT>

<P><TT>myGc.setFillColor(Color.blue);</TT>

<P><TT>myGc.setLineColor(Color.blue);</TT></UL>

<HR WIDTH="100%">
<H4>
<A NAME="Interfaces"></A><FONT COLOR="#9400D3">A Few Interfaces and One
Abstract Class</FONT></H4>
JavaChart uses a variety of Interfaces to assist you in dealing with classes
in a uniform way. For example, you don't need to know if a particular axis
is a linear-scaled Axis, a LabelAxis, a SpeedoAxis or a DateAxis. Certain
functionality is guaranteed to exist because these axes implement AxisInterface.
You can also install a variety of axis styles on a single chart, as long
as the Axis conforms to <A HREF="javachart.chart.AxisInterface.html">AxisInterface.</A>

<P>In JavaChart, interfaces are available for <A HREF="javachart.chart.ChartInterface.html">Chart,</A>
<A HREF="javachart.chart.LegendInterface.html">Legend</A>, and <A HREF="javachart.chart.AxisInterface.html">Axis</A>.
These exist primarily to provide design guidance to individuals who wish
to add new classes to JavaChart while re-using existing classes. For example,
if an individual wanted to build an axis system with labelling based on
Fibonacci sequences, she could still use Line, Bar, or any of the other
pre-existing JavaChart classes.

<P>Similarly, all sorts of Legends can be implemented without subclassing
JavaChart's Legend class. The only requirement, if those legends are going
to be used within pre-existing JavaChart classes, is that the new Legend
conform to our <A HREF="javachart.chart.LegendInterface.html">LegendInterface
class.</A>

<P>Chart is a special case. Visual Engineering provides a set of preconstructed
complete Chart classes that all extend the <A HREF="javachart.chart.Chart.html">Chart
abstract class</A>. Chart is implemented as an abstract class to provide
common functionality shared by various chart types. It's a sort of safety
net to ensure that obscure classes are all initialized, and to simplify
specific Chart classes. You can see by the brevity of source code in <A HREF="../chart/BarChart.java">BarChart.java
</A>that this is an effective approach.

<P><A HREF="javachart.chart.ChartInterface.html">ChartInterface</A> provides
a uniform way to deal with complete charts. Its implementation is certainly
not mandatory for dealing with internal JavaChart classes because it's
not used internally. Rather, ChartInterface provides a uniform way for
you to collaborate with other JavaChart users who may have constructed
custom charts. You can see an example of how this is used in our own <A HREF="../applet/">JavaChart
applets</A>.

<P>
<HR WIDTH="100%">
<H4>
<A NAME="Hierarchy"></A><FONT COLOR="#9400D3">JavaChart Class Hierarchies</FONT></H4>
While the chart package doesn't use extensive subclassing internally, it
does provide some very useful base classes, and provides insight into how
one might extend the base package classes.
<UL><A NAME="Axis"></A><I><FONT COLOR="#FF00FF">Axis</FONT></I>
<UL>All JavaChart axes use the <A HREF="javachart.chart.Axis.html">Axis
class</A> as a parent. This class provides a robust set of properties,
and methods for drawing grid lines, major and minor tick marks, and labels.
This class also implements AxisInterface, and provides methods for automatically
creating scales with reasonable values and increments. Significantly, Axis
also provides a set of utility methods that subclasses can override to
change its behavior. For example, Axis includes a method called drawLine,
which is changed dramatically by <A HREF="javachart.chart.SpeedoAxis.html">SpeedoAxis</A>
to draw curved scales instead of straight scales.

<P>The <A HREF="axis.system.html">Axis chapter </A>describes Axis and its
subclasses in more detail.

<P><A HREF="javachart.chart.LabelAxis.html">Label Axis</A> uses the same
sort of scaling algorithms as Axis, but uses a user-defined list of labels,
rather than automatically generated labels. If a particular LabelAxis increment
doesn't have a label defined, it will use the Dataset element label or
value that corresponds to that location. For example, a BarChart that uses
a LabelAxis might not define labels for the axis. If labels are defined
for the first Dataset in LabelAxis's dataset array, the Dataset label will
be used instead of the (missing) Axis label. As a subclass of Axis, LabelAxis
inherits all of Axis's properties and grid and tick drawing capability.
You can find most of the Axis functions for LabelAxis in the documentation
for Axis.

<P><A HREF="javachart.chart.DateAxis.html">DateAxis</A> also extends Axis,
and uses Axis properties and drawing functions, but alters the way data
is interpreted, and changes the kind of labels that are generated. Specifically,
DateAxis interprets the data values in its <A HREF="javachart.chart.Dataset.html">Dataset</A>
classes to be Date primitive values (number of milliseconds since the "epoch").
By examining the range of Date values in its Dataset classes, a DateAxis
builds an Axis with increments of milliseconds, hours, months, and so on.
The labels are constructed accordingly, using North American English conventions.
DateAxis exposes its methods for constructing labels so that other conventions
can be implemented by subclassing.

<P>Java 1.1 made dramatic changes to the way Dates and calendars are handled.
While this promises to provide much better localization of calendar handling,
much of the local functionality remains unimplemented. Many of the Date
functions used by JavaChart were deprecated, sometimes don't work properly
(especially on pre-release Java 1.1 VMs). We're working on creating a Java
1.1 implementation of DateAxis, but this will not, unfortunately, be transparently
compatible between Java 1.0.2 and Java 1.1.

<P><A HREF="javachart.chart.SpeedoAxis.html">SpeedoAxis</A> is a special
case of Axis that overrides Axis drawing functions but not scaling and
label generating functions. A SpeedoAxis creates a curved scale appropriate
for gauges and dials. While it examines all the data in its Dataset array
for purposes of creating a scale, the Speedo component usually coupled
with a SpeedoAxis draws only a single element: the first Y value of the
first Dataset.</UL>
</UL>

<UL><A NAME="Bar"></A><I><FONT COLOR="#FF00FF">Bar</FONT></I>
<UL><A HREF="javachart.chart.Bar.html">Bars</A> form the primary visual
component of a large set of charts, including vertical, horizontal, stacked,
clustered, and hiLo bars. Bars are usually used to display the value of
discrete categories, with stacks or clusters used to display a group of
observations in the same category. Internally, JavaChart ignores X values
for most kinds of bars, since bars represent categories, rather than a
true 2 dimensional entity. Generally Bar components are given the name
"Bar" (HiLoBar, StackBar, etc.) for horizontal displays, and Column (StackColumn,
IndColumn, etc.) for vertical bars. The exceptions to this rule are the
simple Bar class, which draws a conventional vertical bar chart, and HorizBar,
which draws a conventional horizontal bar chart.

<P>All Bar subclasses change Bar's behavior in some way:
<UL><A HREF="javachart.chart.HorizBar.html">HorizBar</A> arranges the bars
horizontally.

<P><A HREF="javachart.chart.StackBar.html">StackBar</A> and <A HREF="javachart.chart.StackColumn.html">StackColumn</A>
stack multiple observations in a single category, rather than clustering
them.

<P><A HREF="javachart.chart.IndBarChart.html">IndBarChart</A> and <A HREF="javachart.chart.IndColumnChart.html">IndColumnChart</A>
use each Datum's Gc class for bar colors, rather than the Dataset Gc.

<P><A HREF="javachart.chart.HorizHiLoBar.html">HorizHiLoBar</A> and <A HREF="javachart.chart.HiLoBar.html">HiLoBar</A>
examine the Y2 value of each <A HREF="javachart.chart.Datum.html">Datum</A>
to create Gantt style floating bars.</UL>
Bar labels come from each Datum's label value, if it's available. If a
particular Datum has no label defined, Bar uses that Datum's numeric value.

<P>Two Bar subclasses that are less obviously related to the Bar superclass
are <A HREF="javachart.chart.Stick.html">Stick</A> and <A HREF="javachart.chart.HiLoClose.html">HiLoClose</A>
charts. These financial chart styles are able to reuse some of Bar's internal
logic for dealing with discrete observations, and avoid redundant code
by subclassing Bar. These component types do not draw labels.</UL>
</UL>

<UL><A NAME="Line"></A><I><FONT COLOR="#FF00FF">Line</FONT></I>
<UL>Line charts are probably the most commonly used chart. A <A HREF="javachart.chart.Line.html">Line</A>
component is useful for both categorical (individual observations, without
a "real" X value) and dimensional observations. The Line component is used
in JavaCharts complete <A HREF="javachart.chart.DateLineChart.html">DateLineChart</A>,
<A HREF="javachart.chart.RegressChart.html">RegressChart</A>, <A HREF="javachart.chart.LabelLineChart.html">LabelLineChart</A>,
<A HREF="javachart.chart.BarLineChart.html">BarLineChart</A>, <A HREF="javachart.chart.FinComboChart.html">FinComboChart</A>,
and of course <A HREF="javachart.chart.Line.html">LineChart</A>.

<P>JavaChart includes only one Line subclass, Regress. This subclass overrides
Line's draw function to draw an ordinary least squares regression line
for each Dataset in the Line's Dataset array.

<P>Line is used in slightly different ways in each complete Chart class,
however. For example, a LineChart just uses arbitrary X and Y values, while
a DateLineChart assumes that the X values represent Date timestamps. LabelLineChart
assumes monotonically increasing X values, so that each category can be
labelled appropriately.</UL>
</UL>

<UL><A NAME="Legend"></A><I><FONT COLOR="#FF00FF">Legend</FONT></I>
<UL>JavaChart uses 3 different kinds of Legends, based on the Chart type.
All JavaChart legends implement <A HREF="javachart.chart.LegendInterface.html">LegendInterface</A>;
in fact, all JavaChart legends are subclasses of our <A HREF="javachart.chart.Legend.html">Legend</A>
class. An Interface is provided for programmers who wish to create alternate
legend implementations that don't subclass our Legend.

<P>Legend draws a rectangular icon and a label for each class in its Dataset
array. The <A HREF="javachart.chart.LineLegend.html">LineLegend</A> subclass
draws lines and markers instead of rectangles, and the <A HREF="javachart.chart.PieLegend.html">PieLegend</A>
subclass draws an icon for each <A HREF="javachart.chart.Datum.html">Datum</A>
in a single Dataset, rather than one icon for each <A HREF="javachart.chart.Dataset.html">Dataset</A>.</UL>
</UL>

<UL><A NAME="Chart"></A><I><FONT COLOR="#FF00FF">Chart</FONT></I>
<UL><A HREF="javachart.chart.Chart.html">Chart</A> is a useful abstract
superclass for creating all sorts of complete graphs. JavaChart licensees
receive source code to Chart subclasses to see the detailed implementations.
Chances are good that the chart you want is already implemented as a Chart
subclass. If you're looking for something else, it's usually pretty easy
to implement.

<P>One thing to remember about JavaChart's Chart classes is that the internal
components are completely re-usable. You can, for example, create a bar
chart, and then simply transfer the datasets to a line chart for a different
representation. Because of JavaChart's modular construction, you can easily
transfer data, graphical properties, and so on.</UL>
</UL>

<HR WIDTH="100%">
<H4>
<A NAME="Ubiquity"></A><FONT COLOR="#9400D3">Ubiquitous Classes</FONT></H4>
JavaChart uses a few internal classes everywhere.

<P><A HREF="javachart.chart.Gc.html">Gc</A> is a class for storing graphical
properties, such as lineColor and fillColor, as well as methods for drawing.
Although Gc doesn't extend the Java Graphics class, you can think of it
as JavaChart's conduit to Java Graphics.

<P><A HREF="javachart.chart.DisplayList.html">DisplayList</A> is JavaChart's
internal mechanism for collecting chart geometries and associating these
with specific objects. DisplayList's contains() method lets you obtain
a list of JavaChart objects at a particular location. Because every chart
object that draws something is a candidate for entry into the DisplayList,
this class is used almost everywhere.

<P><A HREF="javachart.chart.RotateString.html">RotateString</A> is JavaChart's
internal utility for rotating labels and other character strings. Since
Java doesn't provide any string rotation, the chart package uses raster
operations to rotate Java's fonts.

<P>RotateString and DisplayList need to be available to many classes, but
creating separate instances of these classes for each chart class would
be inefficient and architecturally awkward. To avoid this, we created a
special <A HREF="javachart.chart.Globals.html">Globals</A> class that stores
one instance of these classes and a few properties used by every chart.
One instance of a Globals class is available to almost every class in a
specific Chart. You probably won't access the members of this class very
often, however, because the abstract Chart class provides specific access
methods for Globals properties that need to be exposed.

<P>
<HR WIDTH="100%">
<H4>
<A NAME="Event"></A><FONT COLOR="#9400D3">Event Management</FONT></H4>
The transition from Java 1.0.2 to Java 1.1 created problems as well as
opportunities for Java developers. Java 1.1 and Java Beans provides a healthy
event-driven communication mechanism for inter-application communications.
However, it also means that most applications written for Java 1.0.2 must
be rewritten to take advantage of Java 1.1 facilities.

<P>JavaChart's chart package is concerned with managing and rendering data
using conventional graphical representations. It provides functions for
drawing charts, and for identifying chart objects based on locations, but
it does not attempt to create entire bound applications or applets. JavaChart's
applets provide some of this functionality in the form of robust applets,
and we are working on a set of Java Beans that encapsulates key charting
functions into Beans.

<P>By sending a pixel location to any chart's DisplayList class, you can
receive a list of chart objects at that location. You can also customize
the contents of that list by setting the useDisplayList property for any
drawing chart class. By using this functionality, you can acquire property
information, data values, or any other information stored within JavaChart's
classes.

<P>Since JavaChart doesn't concern itself with managing the flow of events,
you're free to implement either 1.0.2 or 1.1 style event management. If
you need to put a chart into a complete 1.1 style event environment right
away, and receive propertyChange events from outside classes, you can easily
subclass various chart package components to accomplish this. As the functionality
available in Java 1.1 IDEs matures, we intend to make JavaChart's charting
functions as efficient and easy to use as possible for these environments.
To make sure you stay up to date on evolving Java&nbsp; technologies in
JavaChart, check our additional resources in <A HREF="Appendix.B.html">Appendix
B.</A>

<P>
<HR WIDTH="100%">
<CENTER>[<A HREF="index.html">Index</A>] [<A HREF="introduction.html">Introduction</A>]
[<A HREF="installation.html">Installation</A>] [<A HREF="chart.component.html">Component</A>]
[<A HREF="complete.chart.html">Chart</A>] [<A HREF="axis.system.html">Axis</A>]
[<A HREF="utility.html">Utility</A>] [<A HREF="applet.html">Applet</A>]
[<A HREF="Appendix.A.html">Appendix A</A>] [<A HREF="Appendix.B.html">Appendix
B</A>] [<A HREF="Appendix.C.html">Appendix C</A>] [<A HREF="Appendix.D.html">Appendix
D</A>] [<A HREF="packages.html">API</A>]</CENTER>

</BODY>
</HTML>
