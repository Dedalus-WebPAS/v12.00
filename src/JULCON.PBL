. *****************************************************************************
. * System     : Common Source Code                                           *
. * Filename   : JULCON                                                       *
. * Function   : Convert a julian date to gregorian format (DDMMYYCC)         *
. *****************************************************************************
. * Author     : Graeme Williams                                              *
. * Date       : 27/09/1991    (Rewrite to include century)                   *
. * Includes   : JULCALEN                                                     *
. * Mods       :                                                              *
. *****************************************************************************
.
. *****************************************************************************
. * Subroutine : JULCON                                                       *
. * Function   : Convert a julian date to gregorian format (DDMMYYCC)         *
. * Parameters : JWKDAY   - Julian day of year                                *
. *              JWKYER   - Julian year (YY)                                  *
. *              JWKCC    - Julian century (CC)                               *
. * Returns    : DD       - Day of month      (eg. 23 = 23rd of month)        *
. *              MM       - Month of year     (eg. 11 = November)             *
. *              YY       - Year of century   (eg. 89 )                       *
. *              CC       - Century           (eg. 19 = 1900 to 1999)         *
. *****************************************************************************
JULCON    MOVE      JWKDAY,JULDAY            * convert to a form field
          MOVE      JWKYER,JULYR             * convert to a form field
          MOVE      JWKCC,JULCC              * convert to a form field
.
.         If JULDAY is not in the range 1-365 (or 1-366 for a leap year)
.         then adjust the year appropriately to make it in this range.
.
          MOVE      JULYR,YY                 * current year
          MOVE      JULCC,CC                 * current century
          CALL      JULCHKDE                 * make sure it is the right range
.
          MOVE      ZERO,MM                  * initialise month
          MOVE      YY,JULYR                 * save year
          MOVE      CC,JULCC                 * save century
.
CDJ3      ADD       ONE,MM                   * increment month
.
.         Get the number of days upto the start of this month
.
          LOAD      JULWK FROM MM OF JJAN,JFEB,JMAR:
                    JAPR,JMAY,JJUN,JJUL,JAUG,JSEP:
                    JOCT,JNOV,JDEC
.
.         Special case, allow for the current year being a leap year
.
          COMPARE   THREE,MM                 * after february ?
          GOTO      CDJ4 IF LESS             * no, not affected by leap year
.
.         The leap year flag is "1" for a leap year, and "0" otherwise. Thus
.         we can use this flag as the number of days extra in the current year.
.
          ADD       LEAPYR,JULWK
.
.         Check if the day number (julian day) is in this month
.
CDJ4      COMPARE   JULDAY,JULWK             * have we past the month ?
          GOTO      CDJ5 IF NOT LESS         * yes. Go back to previous month
.
.         Day is greater than or equal to this month, keep looking.
.
          MOVE      JULWK,JHOLD              * remember the number of days
.
.         If the current month is december, then we have finished loop.
.         Otherwise, loop forward to the next month, and check it.
.
          COMPARE   TEN2,MM                  * reached december ?
          GOTO      CDJ3 IF LESS             * no, try next month
.
          ADD       ONE,MM                   * adjust for SUB ONE,MM below
.
.         Go back to the previous month. This is because we have check one
.         month too many.
.
CDJ5      SUB       JHOLD,JULDAY             * calculate the day of the month
          MOVE      JULDAY,DD                * return value
          SUB       ONE,MM                   * go back to previous month
          RETURN
.
. *****************************************************************************
. * Subroutine : JULCHKDE                                                     *
. * Function   : Make sure julian date is in the range of 1-365 (or 1-366)    *
. * Parameters : JULDAY   - Julian day of year                                *
. *              YY       - Julian year (YY)                                  *
. *              CC       - Julian century (CC)                               *
. * Returns    : JULDAY   - Julian day                                        *
. *              YY       - Julian year (YY)                                  *
. *              CC       - Julian century (CC)                               *
. *****************************************************************************
.
JULCHKDE  CALL      JULEAPYR                  * set leap year flag
.
.         Check if we should be in the next year
.
          BRANCH    LEAPYR,JULCHK10           * allow for leap year
.
          COMPARE   "366",JULDAY              * non-leap year ends on day 365
          GOTO      JULCHK50 IF LESS          * not into next year
.
          SUB       "365",JULDAY              * bring back into this year
          GOTO     JULCHK30                   * increment year
.
JULCHK10  COMPARE   "367",JULDAY              * leap year ends on day 366
          GOTO      JULCHK50 IF LESS          * not into next year
.
          SUB       "366",JULDAY              * bring back into this year
.
.         We have moved into the next year. Increment year by one.
.
JULCHK30  ADD       ONE,YY                    * increment year
          COMPARE   ZERO,YY                   * check for a new century
          GOTO      JULCHKDE IF NOT EQUAL     * no, recheck julian date
          ADD       ONE,CC                    * increment century
          GOTO      JULCHKDE                  * recheck julian date
.
.         Check if we should be in the previous year
.
JULCHK50  COMPARE   ONE,JULDAY                * check if julian day is below 1
          GOTO      JULCHK99 IF NOT LESS      * not in previous year
.
.         We have moved in to the previous year. Decrement year by one.
.
          COMPARE   ZERO,YY                   * year zero ?
          GOTO      JULCHK60 IF EQUAL         * yes, decrement century as well
.
          SUB       ONE,YY                    * goto previous year
          GOTO      JULCHK80                  * fix up day number
.
JULCHK60  MOVE      "99",YY                   * new year
          SUB       ONE,CC                    * decrement century
.
.         Fix up day number for this new year
.
JULCHK80  CALL      JULEAPYR                  * set leap year flag
.
          ADD       "365",JULDAY              * days in previous year
          ADD       LEAPYR,JULDAY             * adjust for leap year
          GOTO      JULCHKDE                  * recheck julian date
.
JULCHK99  RETURN
.
. *****************************************************************************
. * Subroutine : JULEAPYR                                                     *
. * Function   : Set the leap year flag if current year is a leap year        *
. * Parameters : YY       - Julian year (YY)                                  *
. *              CC       - Julian century (CC)                               *
. * Returns    : LEAPYR   - Leap year flag  0 = No, 1 = Yes                   *
. *****************************************************************************
.
JULEAPYR  MOVE      YY,JULWK                 * work variable
.
.         Check if the year is divisible by four. If it isn't, then this is not
.         a leap year.
.
          DIV       FOUR,JULWK               * divide by four, truncating
          MULT      FOUR,JULWK               * multiple to get modulus
.
          COMPARE   YY,JULWK                 * are they still the same ?
          GOTO      JULEAP90 IF NOT EQUAL    * no, this is not a leap year
.
.         The year is divisible by four. We probably have a leap year. However
.         there is one special case to handle. If the year is divisible by
.         100, and not 400, then this is NOT a leap year (the last time this
.         happenned was in 1900, then next time is 2100).
.
          COMPARE   ZERO,YY                  * year 0 (divisible by 100) ?
          GOTO      JULEAP80 IF NOT EQUAL    * no, this is a leap year
.
          MOVE      CC,JULWK                 * work variable
.
          DIV       FOUR,JULWK               * divide by four, truncating
          MULT      FOUR,JULWK               * multiple to get modulus
.
          COMPARE   CC,JULWK                 * are they still the same ?
          GOTO      JULEAP90 IF NOT EQUAL    * no, this is not a leap year
.
.         This is a leap year
.
JULEAP80  MOVE      ONE,LEAPYR
          GOTO      JULEAP99
.
.         This is not a leap year
.
JULEAP90  MOVE      ZERO,LEAPYR
.
JULEAP99  RETURN
