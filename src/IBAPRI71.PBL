.******************************************************************************
.* System   :  PRIVATE PRACTICE SYSTEM                                        *
.* Program  :  IBAPRI71                                                       *
.* Desc     :  PRINT GENERAL LETTERS                                          *
.******************************************************************************
.* Date     :  11/12/91                                                       *
.* Author   :  DIG                                                            *
.* Comment  :  This program was written using IBAPMS89 (Print                 *
.*             Inpatient Letters) as the standard to work from.               *
.*                                                                            *
.*             I have temporarily commented out the code using the 4          *
.*             user defined fields from the Debtor file as they will          *
.*             not be applicable for U/R numbers. Hopefully a                 *
.*             decision will be made at some stage as to what to do           *
.*             with them.                                                     *
.* Mods     :                                                                 *
.******************************************************************************
.* V11.04.03 22/07/2024  Thanh T           TSK 0939648                        *
.*          Added LCPXSN18/%secraddr - Secure Address                        *
.*                 LCPXSN19/%verfaddr - Verified Address                      *
.*                 LCPXSN20/%multbirt - Multiple Birth Indicator              *
.*                 LCPXSN21/%emailval - Email Validation Flag                 *
.*                 LCPXSN22/%statusbb - Status Indicator 22                   *
.*                 LCPXSN23/%statusbc - Status Indicator 23                   *
.*                 LCPXSN24/%statusbd - Status Indicator 24                   *
.*                 LCPXSN25/%statusbe - Status Indicator 25                   *
.*                 LCPXSN26/%statusbf - Status Indicator 26                   *
.*                 LCPXSN27/%statusbg - Status Indicator 27                   *
.*                 LCPXSN28/%statusbh - Status Indicator 28                   *
.*                 LCPXSN29/%statusbi - Status Indicator 29                   *
.*                 LCPXSN30/%statuscz - Status Indicator 30                   *
.* V11.04.02 09/05/2024 Nikitha B      TSK 0945225                            *
.*           Increased size of COUNT from FORM 2 to FORM 3 to fit more than 99* 
.*           lines to print.                                                  *
.* V11.04.01 05.02.2024 DA Sarkies     TSK 0936282                            *
.*           Increased size of variable to hold Healthfund Number             *
.* V10.01.01 03/02/2011 Jill Parkinson CAR 233088                             *
.*                  Added pmsvx1af                                            *
.* V9.08.01  14/05/2007  Peter Vela    CAR 136586                             *
.*           Recompiled for PRIINVPR - Added SJOG Referral Doctor details     *
.* V9.03.04  01/03/2004 Lina Vo             47921                             *
.*           Removed use of PRIDBTFD & IO.                                    *
.* V9.03.03  10/02/2004 Lina Vo             44132                             *
.*           Fixed infinite loop problem when last letter in priletaf selected*
.*           for printing.  Mods to PRLT0000 to read letter header record     *
.*           first.                                                           *
.*           Fixed Web Select letters.  The comparison for TVSURN1 & TVSURN2  *
.*           was not selecting correct records for surname option.            *
.* V9.03.02  29/10/2003 Sandra Barcham      43783                             *
.*           Recompiled for NZHISIIO and NZHISIUP                             *
.* V9.03.01  14/10/2003  Tracey Nguyen  CAR 44125                             *
.*           Recompiled to pick up renamed spare variable in PRILETFD         *
.******************************************************************************
.* V9.02.03  06/11/2002  J.Tan                                                *
.*           Recompiled for PRIKYDEB - merge U/R                              *
.* V9.02.02  30/11/2001  Dean Cramer                                          *
.*           Mods for Web                                                     *
.* V9.02.01  02/10/2001  J.Tan                                                *
.*           Mods to use PMSHCPFD instead of PATDO1FD                         *
.* V9.00.B01 13/06/2001  Steve Armstrong       Call 10742                     *
.*           Recompiled for changes to PRIKYDEB                               *
.******************************************************************************
.*        V5.10.B01 26/03/2001  Glenn Saunders                                *
.*                  Remove access to PTCNSNDX and associated processing.      *
.*                  Remove all references to PATSUR file (old surname file).  *
.******************************************************************************
.*        V5.08.03  16/08/2000  Caleb Sharman                                 *
.*                  Changed Health Fund variables to be 8 chars               *
.*        V5.08.02  17/05/2000  J Habasque                                    *
.*                  Added open of controlf                                    *
.*        V5.08.01  05/05/2000  J.Tan                                         *
.*                  Recompiled for PRIDOCT file                               *
.*        V5.07.03  12/10/1999  J Habasque                                    *
.*                  Recompiled for PRIHRTFD                                   *
.*        V5.07.02  23/06/1999  Greg Horvat                                   *
.*                  Changed to use PRIMPDKY to keyin the PP service doctor    *
.*        V5.07.01  09/06/1999  Greg Horvat                                   *
.*                  Recompiled for PRIINVIO - Fixed problem with direct read  *
.*        V5.04.01  14/06/1997  Steve Armstrong                               *
.*                  Fixed bugs in global recompile                            *
.******************************************************************************
.*             V6.01  18/03/92  DIG                                   *
.*                    Recompiled for changes to PRIHTRFD + PRIHREFD   *
.*             V6.00.02 07/10/92  Steve Armstrong                     *
.*                    Modified for alphanumeric debtor number         *
.*             V6.00.03 27/01/1993  Steve Armstrong  SRF 120122 Q7558 *
.*                    Mods for new PRIHTRFD format                    *
.*        V6.00.04  12/08/1993  Glenn Berry      SRF 122974           *
.*                  Mods for changes to PRIHTRFD                      *
.*        V6.01.01  20/01/1994  Greg Horvat      SRF 127350           *
.*                  Recompiled for changes to PRIVRDEB.INC            *
.*        V5.03.01  07/08/1995  Steve Armstrong                       *
.*                  Recompiled for PRIKYDEB                           *
.*                                                                    *
.**********************************************************************
.
          INC       STD001FD
.
          INC       PRIVRDEB/INC
.
          INC       BOKRC1FD/INC
.
          INC       OUTPREFD/INC
.
          INC       PATCODFD/INC
          INC       PATCONFD/INC
          INC       PMSHCPFD/INC
          INC       PATGSRFD/INC
          INC       PATMA1FD/INC
          INC       PMSPX2FD/INC
          INC       PATMI1FD/INC
          INC       PMSVX1FD/INC
          INC       PATPR1FD/INC
          INC       PRICONFD/INC
...          INC       PRIDBTFD/INC
          INC       PRIDOCFD/INC
          INC       PRIDTRFD/INC
          INC       PRIHDBFD/INC
          INC       PRIHREFD/INC
          INC       PRIHTRFD/INC
          INC       PRIINVFD/INC
          INC       PRILETFD/INC
          INC       PRIPRAFD/INC
          INC       PRIGLSFD/INC
          INC       PRIGSLFD/INC
.
          INC       PATCOMM/INC                  * common file
          INC       PATALRFD/INC                 * Alerts & Medical Warnings
          INC       NZHISIFD/INC                 * NZHIS Variables
          INC       NHIMASFD/INC                 * NZHIS Variables
          INC       PATDHEAD/INC                 * PMI Header Details
          INC       PATCALAG/INC                 * PMI Age Calc
          INC       PMIVARS/INC                  * PMI Variables
          INC       SCRPSTFD/INC
.
.**********************************************************************
.*                           TEMP FILE                                *
.**********************************************************************
PRITM1XX  IFILE     SQL, FIXED=38, KEY="U1-8,9-10,11-18"
.
. NAME    TYPE    LENGTH     PHYSICAL    START LOC.    DESCRIPTION
. ----    ----    ------     --------    ----------    -----------
TMPDEBT   DIM       8           8             1        Debtor number
DTMPSCAN  DIM       2           2             9        Scan Flag
.                                                         0 = Debtor
.                                                         1 = U/R    
DTMPUNIQ  DIM       8           8            11        Unique Identifier
TMPPRAC   DIM       6           6            19        Medical Practice
TMPSDOC   DIM      10          10            25        Service Doctor
TMPPIND   DIM       3           3            35        Patient Indicator
.End of record                               38
.
. Redefine form fields from key
. -----------------------------
TMPSCAN   FORM      2
TMPUNIQ   FORM      8
+
.**********************************************************************
.*                           CONSTANTS                                *
.**********************************************************************
CODEA     INIT      "A "
CODECC    INIT      "CC"
CODECL    INIT      "CL"
CODED     INIT      "D "
CODEG1    INIT      "G1"
CODEG2    INIT      "G2"
CODEG3    INIT      "G3"
CODEG4    INIT      "G4"
CODEG5    INIT      "G5"
CODEG6    INIT      "G6"
CODEG7    INIT      "G7"
CODEG8    INIT      "G8"
CODEGA    INIT      "GA"
CODEP     INIT      "P "
CODES     INIT      "S "
CODEU1    INIT      "U1"
CODEU2    INIT      "U2"
CODEU3    INIT      "U3"
CODEU4    INIT      "U4"
CODEU5    INIT      "U5"
.
DALIVE    INIT      "Alive   "
DCANC     INIT      "Canceled"
DCURR     INIT      "Current "
DDECEASE  INIT      "Deceased"
DEXT1     INIT       "st"
DEXT2     INIT       "nd"
DEXT3     INIT       "rd"
DEXT4     INIT       "th"
DONLV     INIT      "On-leave"
DPREA     INIT      "Pre-Admn"
.
FINISH    INIT      "Finish"
.
LCACDATE  INIT      "%acdate"           * Accident Date
LCACLASS  INIT      "%aclass"           * Admission Class
LCADDA    INIT      "%adda"             * Address Line 1
LCADDB    INIT      "%addb"             * Address Line 2
LCADDC    INIT      "%addc"             * Address Line 3                    *5
LCCLMDES  INIT      "%clmdesc"          * Claim Code Description
LCDATE    INIT      "%date"             * Today's Date
LCDEBTNO  INIT      "%debtno"           * Debtor Number
LCDOB     INIT      "%dob"              * Date Of Birth
LCDUSR1   INIT      "%dusra"            * Debtor User Defined Field 1       *10
LCDUSR2   INIT      "%dusrb"            * Debtor User Defined Field 2
LCDUSR3   INIT      "%dusrc"            * Debtor User Defined Field 3
LCDUSR4   INIT      "%dusrd"            * Debtor User Defined Field 4
LCFRSTI   INIT      "%frsti"            * Patient First Initial
LCFNAME   INIT      "%fname"            * Patient Full Name                 *15
LCGNAME   INIT      "%gname"            * Patient Given Name
LCHFMEM   INIT      "%hfmemno"          * Health Fund Membership Number
LCHFTAB   INIT      "%hftable"          * Health Fund Table
LCHFUND   INIT      "%hfund"            * Health Fund
LCHOSP    INIT      "%hosp"             * Hospital Name                     *20
LCHADDA   INIT      "%hadda"            * Hospital Address Line 1
LCHADDB   INIT      "%haddb"            * Hospital Address Line 2
LCHADDC   INIT      "%haddc"            * Hospital Address Line 3
LCHPOST   INIT      "%hpost"            * Hospital Postcode
LCHTELE   INIT      "%htele"            * Home Telephone Number             *25
LCLETDAT  INIT      "%letdat"           * Date of letter
LCMEDNO   INIT      "%mednum"           * Medicare Number
LCPAGE    INIT      "%page"             * Page Break Variable
LCPCODE   INIT      "%pcode"            * Patient Post Code
LCPRADES  INIT      "%pracdes"          * Practice Description              *30
LCPRAADA  INIT      "%praada"           * Practice Address Line 1
LCPRAADB  INIT      "%praadb"           * Practice Address Line 2
LCPRAADC  INIT      "%praadc"           * Practice Address Line 3
LCPRAPOS  INIT      "%prapos"           * Practice Postcode
LCPRATEL  INIT      "%pratel"           * Practice Telephone Number         *35
LCRESACC  INIT      "%resacc"           * Person Responsible for Account
LCRESADA  INIT      "%resadda"          * Person Responsible Address 1
LCRESADB  INIT      "%resaddb"          * Person Responsible Address 2
LCRESADC  INIT      "%resaddc"          * Person Responsible Address 3
LCRESPCD  INIT      "%respost"          * Person Responsible Post Code      *40
LCRESHTL  INIT      "%reshtel"          * Person Responsible Home Telephone
LCRESWTL  INIT      "%reswtel"          * Person Responsible Work Telephone
LCRESREL  INIT      "%resrel"           * Person Responsible Relationship
LCRDFIN   INIT      "%rdfin"            * Referring Doctor First Initial
LCRDGIV   INIT      "%rdgiv"            * Referring Doctor Given Names      *45
LCRDNAM   INIT      "%rdnam"            * Referring Doctor Full Name
LCRDSUR   INIT      "%rdsur"            * Referring Doctor Surname
LCRDTITL  INIT      "%rdtitl"           * Referring Doctor Title
LCRUSR1   INIT      "%rusra"            * Referral User Defined Field 1
LCRUSR2   INIT      "%rusrb"            * Referral User Defined Field 2     *50
LCRUSR3   INIT      "%rusrc"            * Referral User Defined Field 3
LCRUSR4   INIT      "%rusrd"            * Referral User Defined Field 4
LCSDFIN   INIT      "%rsfin"            * Service Doctor First Initial
LCSDGIV   INIT      "%rsgiv"            * Service Doctor Given Names
LCSERDOC  INIT      "%serdoct"          * Service Doctor                    *55
LCSDSUR   INIT      "%rssur"            * Service Doctor Surname
LCSDTITL  INIT      "%rstitl"           * Service Doctor Title
LCSNAME   INIT      "%sname"            * Patient Surname
LCTITLE   INIT      "%title"            * Patient Title
LCVISDAT  INIT      "%visdat"           * Visit Date                        *60
LCWTELE   INIT      "%wtele"            * Work Telephone Number
LCPXSN18  INIT      "%secraddr"         * Secure Address
LCPXSN19  INIT      "%verfaddr"         * Verified Address
LCPXSN20  INIT      "%multbirt"         * Multiple Birth Indicator
LCPXSN21  INIT      "%emailval"         * Email Validation Flag             *65
LCPXSN22  INIT      "%statusbb"         * Status Indicator 22               
LCPXSN23  INIT      "%statusbc"         * Status Indicator 23
LCPXSN24  INIT      "%statusbd"         * Status Indicator 24
LCPXSN25  INIT      "%statusbe"         * Status Indicator 25
LCPXSN26  INIT      "%statusbf"         * Status Indicator 26               *70
LCPXSN27  INIT      "%statusbg"         * Status Indicator 27               
LCPXSN28  INIT      "%statusbh"         * Status Indicator 28
LCPXSN29  INIT      "%statusbi"         * Status Indicator 29
LCPXSN30  INIT      "%statuscz"         * Status Indicator 30               *74
.
.
. ----- Maximum Field Lengths for the Variables Above -----
.
.
LXACDATE  INIT      "99/99/9999"
LXACLASS  INIT      "XXXXXXXXXXXXXXXXXXXX"
LXADDA    INIT      "XXXXXXXXXXXXXXXXXXXXXXXXX"
LXADDB    INIT      "XXXXXXXXXXXXXXXXXXXXXXXXX"
LXADDC    INIT      "XXXXXXXXXXXXXXXXXXXXXXXXX"                             *5
LXCLMDES  INIT      "XXXXXXXXXXXXXXXXXXXX"
LXDATE    INIT      "99th XXXXXXXXX 1999"
LXDEBTNO  INIT      "XXXXXXXX"
LXDOB     INIT      "99/99/9999"
LXDUSR1   INIT      "XXXXXXXXXXXXXXXXXXXX"                                  *10
LXDUSR2   INIT      "XXXXXXXXXXXXXXXXXXXX"
LXDUSR3   INIT      "XXXXXXXXXXXXXXXXXXXX"
LXDUSR4   INIT      "XXXXXXXXXXXXXXXXXXXX"
LXFRSTI   INIT      "X"
LXFNAME   INIT      "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"  *15 
LXGNAME   INIT      "XXXXXXXXXXXXXXXXXXXXXXXXX"
LXHFMEM   INIT      "9999999999999999999"
LXHFTAB   INIT      "XXXXXXXX"
LXHFUND   INIT      "XXXXXX"
LXHOSP    INIT      "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"                   *20
LXHADDA   INIT      "XXXXXXXXXXXXXXXXXXXXXXXXX"
LXHADDB   INIT      "XXXXXXXXXXXXXXXXXXXXXXXXX"
LXHADDC   INIT      "XXXXXXXXXXXXXXXXXXXXXXXXX"
LXHPOST   INIT      "XXXX"
LXHTELE   INIT      "999999999999"                                          *25
LXLETDAT  INIT      "99/99/9999"
LXMEDNO   INIT      "9999999999"
LXPAGE    INIT      "X       ------          page ":
                    "break       ------        X"
LXPCODE   INIT      "9999" 
LXPRADES  INIT      "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"                        *30 
LXPRAADA  INIT      "XXXXXXXXXXXXXXXXXXXXXXXXX"
LXPRAADB  INIT      "XXXXXXXXXXXXXXXXXXXXXXXXX"
LXPRAADC  INIT      "XXXXXXXXXXXXXXXXXXXXXXXXX"
LXPRAPOS  INIT      "XXXX"
LXPRATEL  INIT      "XXXXXXXXXXXX"                                          *35
LXRESACC  INIT      "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"
LXRESADA  INIT      "XXXXXXXXXXXXXXXXXXXXXXXXX"
LXRESADB  INIT      "XXXXXXXXXXXXXXXXXXXXXXXXX"
LXRESADC  INIT      "XXXXXXXXXXXXXXXXXXXXXXXXX"
LXRESPCD  INIT      "9999"                                                  *40
LXRESHTL  INIT      "999999999999"
LXRESWTL  INIT      "999999999999"
LXRESREL  INIT      "XXXXXXXXXX"
LXRDFIN   INIT      "X"
LXRDGIV   INIT      "XXXXXXXXXXXXXXXXXXXXXXXXX"                             *45 
LXRDNAM   INIT      "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"
LXRDSUR   INIT      "XXXXXXXXXXXXXXXXXXXX"
LXRDTITL  INIT      "XXXXXXXXX"
LXRUSR1   INIT      "XXXXXXXXXXXXXXXXXXXX"
LXRUSR2   INIT      "XXXXXXXXXXXXXXXXXXXX"                                  *50
LXRUSR3   INIT      "XXXXXXXXXXXXXXXXXXXX"
LXRUSR4   INIT      "XXXXXXXXXXXXXXXXXXXX"
LXSDFIN   INIT      "X"
LXSDGIV   INIT      "XXXXXXXXXXXXXXXXXXXXXXXXX"                             *54
LXSERDOC  INIT      "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"
LXSDSUR   INIT      "XXXXXXXXXXXXXXXXXXXX"
LXSDTITL  INIT      "XXXXXXXXX"
LXSNAME   INIT      "XXXXXXXXXXXXXXXXXXXX"
LXTITLE   INIT      "XXXX"
LXVISDAT  INIT      "99/99/9999"                                            *60 
LXWTELE   INIT      "999999999999"
LXPXSN18  INIT      "X"
LXPXSN19  INIT      "X"
LXPXSN20  INIT      "X"
LXPXSN21  INIT      "X"                                                     *65
LXPXSN22  INIT      "X"                                                     
LXPXSN23  INIT      "X"
LXPXSN24  INIT      "X"
LXPXSN25  INIT      "X"
LXPXSN26  INIT      "X"                                                     *70
LXPXSN27  INIT      "X"                                                     *71
LXPXSN28  INIT      "X"
LXPXSN29  INIT      "X"
LXPXSN30  INIT      "X"                                                     *74
.
MONTH1    INIT      "January"
MONTH2    INIT      "February"
MONTH3    INIT      "March"
MONTH4    INIT      "April"
MONTH5    INIT      "May"
MONTH6    INIT      "June"
MONTH7    INIT      "July"
MONTH8    INIT      "August"
MONTH9    INIT      "September"
MONTH10   INIT      "October"
MONTH11   INIT      "November"
MONTH12   INIT      "December"
.
NINE8     FORM      "99999999"
.
REPSTR    INIT      "a0b0c0d0e0f0g0h0i0j0k0l0m0n0o0p0q0r0s0t0u0v0w0x0y0z0"
.
SP60      INIT      "                              ":
                    "                              "
SPECCHAR  INIT      "%"
STAR45    INIT      "*********************************************"
STAR52    INIT      "****************************************************"
STAR56    INIT      "********************************************************"
START     INIT      "Start "
.
.
ZED6      INIT      "zzzzzz"
ZEDS      INIT      "ZZZZZZZZZZZZZZZZZZZZ"
ZEROS8    INIT      "00000000"
+
.**********************************************************************
.*                        GLOBAL  VARIABLES                           *
.**********************************************************************
BOTTMARG  FORM      2
.
CMDLINE   DIM       60
CODE      DIM       2
CONAME    DIM       35
COUNT     FORM      3
COUNTER   FORM      2
.
DCODE     DIM       10
DATELINE  DIM       19
DBTGNAM   DIM       25
DBTSNAM   DIM       20
DDEBT1    DIM       8
DDEBT2    DIM       8
DEBTNO    DIM       8
DESCCLAM  DIM       15
DESCPRAC  DIM       15
DEXT      DIM       3
DIM3      DIM       3
DIM15     DIM       15 
DIM30     DIM       30
DIM51     DIM       51
DIM55     DIM       55
DIM70     DIM       70
DIMOPTN   DIM       2
DISPSTRN  DIM       70
DOCNAME   DIM       18
DOCTOR    DIM       6  
.
EDOCT     DIM       6 
ENDSTR    FORM      2
ENUMB     DIM       8
EPRAC     DIM       6
.
FIRSTCH   FORM      1
FLAGALL   FORM      1
FLAGDEBT  FORM      1
FLAGCLAM  FORM      1
FLAGPRAC  FORM      1
FLAGSURN  FORM      1
FLAGSDOC  FORM      1
FLAGUDF1  FORM      1
FLAGUDF2  FORM      1
FLAGUDF3  FORM      1
FLAGUDF4  FORM      1
FLAGUDF5  FORM      1
FLAGUDF6  FORM      1
FLAGUDF7  FORM      1
FLAGUDF8  FORM      1
FLAGURNO  FORM      1
FLAGVIST  FORM      1
FNAMER    DIM       8
FORM3     FORM      3
FORM3A    FORM      3
.
KEYST1    DIM       18
KEYST2    DIM       18
KEYST3    DIM       18
KEYST4    DIM       18
KEYST5    DIM       18
KEYST6    DIM       18
KEYST7    DIM       18
KEYST8    DIM       18
KEYST9    DIM       18
KEYST10   DIM       18
KEYST11   DIM       18
KEYST12   DIM       18
KEYST13   DIM       18
KEYST14   DIM       18
KEYST15   DIM       18
KEYST16   DIM       18
KEYST17   DIM       18
KEYST18   DIM       18
.
LEFTMARG  FORM      2
LETTDATE  DIM       10
LETTFORM  FORM      3
LINE      DIM       65
.
MLETPLEN  FORM      3
MONTH     DIM       9
MPDESC    DIM       30
MPRAC     DIM       6
.
OPTNNUMB  FORM      2
.
PATNAME   DIM       15
PERCPOS   FORM      2
PHYSPAGE  FORM      3
PRTSTRNG  DIM       70
.
QUESTFLG  FORM      1
.
RECCOUNT  FORM      3
RECNUMB   FORM      2
.
SCRNPOS   FORM      2
SCRNNUMB  FORM      2
SDOCT     DIM      10
SELECTID  DIM       4
SELFLAG   FORM      1
SNUMB     DIM       8   
SPRAC     DIM       6
SRCHNUM   FORM      2
STARTSTR  FORM      2
.
TDADCL1   DIM       6
TDADCL2   DIM       6
TDADTY1   DIM       6
TDADTY2   DIM       6
TDCLAM1   DIM       6
TDCLAM2   DIM       6
TDCOBT1   DIM       6
TDCOBT2   DIM       6
TDCRCL1   DIM       6
TDCRCL2   DIM       6
TDDCST    DIM       8
TDDSST1   DIM       6
TDDSST2   DIM       6
TDHTFD1   DIM       6
TDHTFD2   DIM       6
TDMEMB    DIM       3
TDRELG1   DIM       6
TDRELG2   DIM       6
TDRFSC1   DIM       6
TDRFSC2   DIM       6
TDSURN1   DIM       20
TDSURN2   DIM       20
TD1UDF1   DIM       6
TD1UDF2   DIM       6
TD2UDF1   DIM       6
TD2UDF2   DIM       6
TD3UDF1   DIM       6
TD3UDF2   DIM       6
TD4UDF1   DIM       6
TD4UDF2   DIM       6
TD5UDF1   DIM       6
TD5UDF2   DIM       6
TD6UDF1   DIM       6
TD6UDF2   DIM       6
TD7UDF1   DIM       6
TD7UDF2   DIM       6
TD8UDF1   DIM       6
TD8UDF2   DIM       6
TDURNO1   DIM       8
TDURNO2   DIM       8
TDVIST1   DIM       10
TDVIST2   DIM       10
TEMP2     FORM      2
TEMP3     FORM      3
TEMP55    DIM       55
TEMP70    DIM       70
TEMPLETT  DIM       3
TOPMARG   FORM      2
.
TVADCL1   DIM       3
TVADCL2   DIM       3
TVADTY1   DIM       3
TVADTY2   DIM       3
TVCLAM1   DIM       3
TVCLAM2   DIM       3
TVCOBT1   DIM       3
TVCOBT2   DIM       3
TVCRCL1   DIM       3
TVCRCL2   DIM       3
TVDCST    DIM       1
TVDSDT1   DIM       6
TVDSDT2   DIM       6
TVDSST1   DIM       3
TVDSST2   DIM       3
TVHTFD1   DIM       6
TVHTFD2   DIM       6
TVMEMB    DIM       1
TVRELG1   DIM       3
TVRELG2   DIM       3
TVRFSC1   DIM       3
TVRFSC2   DIM       3
TVSURN1   DIM       20
TVSURN2   DIM       20
TVURNO1   FORM      8
TVURNO2   FORM      8
TV1UDF1   DIM       3
TV1UDF2   DIM       3
TV2UDF1   DIM       3
TV2UDF2   DIM       3
TV3UDF1   DIM       3
TV3UDF2   DIM       3
TV4UDF1   DIM       3
TV4UDF2   DIM       3
TV5UDF1   DIM       3
TV5UDF2   DIM       3
TV6UDF1   DIM       3
TV6UDF2   DIM       3
TV7UDF1   DIM       3
TV7UDF2   DIM       3
TV8UDF1   DIM       3
TV8UDF2   DIM       3
TVVIST1   DIM       8
TVVIST2   DIM       8
.
BJDAY     FORM      3
CJDAY     FORM      3
URDIM8    DIM       8
.
PRGNAM    INIT      "Print General Letters"
PRGID     INIT      "IBAPRI71"
VERSION   INIT      "V12.00.00"
.
.**********************************************************************
.*                             MAINLINE                               *
.**********************************************************************
ML0000    CALL      INIT0000                      * Initialize
          MATCH     "IBARSH",PGM
          GOTO      ML7000 IF EQUAL      
.
.------ display main option screen ------
.
ML0100    CALL      OPTN0000                      * Main Option Screen
          BRANCH    EXIT,ML9999
.
          CALL      CLR0000                       * Clear Variables
          CALL      SCRN0000                      * Call Adhoc Screen
.
.------ select an option ------
.
ML0200    CALL      SEL0000                       * Select Options
          BRANCH    EXIT,ML0100,ML5000
.
          BRANCH    OPTION,ML1000,ML1100,ML1200,ML1300,ML1400,ML1500
.
          GOTO      ML2000                       * Choice in User Defineds
.
.------ keyin debtor or U/R range ------
.
ML1000    CALL      DEBT0000                     * Input Debtor or U/R Number 
          GOTO      ML0200
.
.------ keyin surname range ------
.
ML1100    CALL      SURN0000                     * Input Surname Range
          GOTO      ML0200
.
.------ keyin visit date range ------
.
ML1200    CALL      VIST0000                     * Input Visit Date Range
          GOTO      ML0200
.
.------ keyin start medical practice ------
.
ML1300    CALL      SPRA0000                     * Input start medical Practice
          BRANCH    EXIT,ML0200
.
          CALL      EPRA0000                     * Input end medical practice
          GOTO      ML0200
.
.------ keyin start doctor ------
.
ML1400    CALL      SDOC0000                     * Input start Service Doctor
          BRANCH    EXIT,ML0200
.
          CALL      EDOC0000                     * Input end service doctor
          GOTO      ML0200
.
.------ keyin claim code range ------
.
ML1500    CALL      CLAM0000                     * Input Claim Code Range
          GOTO      ML0200
.
.------ process the user defined fields ------
.
ML2000    CALL      USDF0000                     * Process the User Defineds
          GOTO      ML0200
.
.------ O.K. to process so create the indexed temp file ------
.
ML5000    CALL      CREA0000                     * create the indexed temp file
.
          CALL      EXTR0000                     * Extract Patients
          BRANCH    EXIT,ML0200
.
          CALL      GETSCR00                     * save the screen
.
.------ process the patients extracted ------
.
ML6000    CALL      PATS0000                     * Process Patients
          BRANCH    EXIT,ML0200
.
          CALL      SEND0000                     * Send Letter to Patients
          BRANCH    EXIT,ML6000,ML0200
          GOTO      ML0200
.
ML7000    CALL      CLR0000                       * Clear Variables
          CALL      OPTW0000
          BRANCH    OPTION,ML7200,ML7400,ML7600
          GOTO      ML9999
.
ML7200    CALL      SELW0000
          BRANCH    EXIT,ML9999
.
          CALL      DELW0000
          CALL      SETW0000
          CALL      EXTR0000
          GOTO      ML9999
.
ML7400    CALL      SELW0000
          CALL      SENW0000
          GOTO      ML9999
.
ML7600    CALL      DSEL0000
          BRANCH    EXIT,ML9999
.
          CALL      DELW0000
.
ML9999    CHAIN     PGM
          STOP
.
.********************************************************************** 
.*                            INIT0000                                *
.*                       Initialize Routine                           *
.********************************************************************** 
INIT0000  CALL      DISPHEAD                * display the header
.
          DISPLAY   *P64:24,"Opening":
                    *P72:24,"patcodes";
          OPEN      PATCODE1,"patcodes"
.
          DISPLAY   *P64:24,"pmshcpaf";
          OPEN      PMSHCPA1,"pmshcpaf"
.
          DISPLAY   *P72:24,"patma1af";
          OPEN      PATMA1A1,"patma1af"
          OPEN      PATMX1A1,"patmx1af"
          OPEN      PMSPX2A1,"pmspx2af"
.
          DISPLAY   *P72:24,"patmi1af";
          OPEN      PATMI1A1,"patmi1af"
          OPEN      PATMI1A2,"patmi1af"
          OPEN      PATMI1A3,"patmi1af"
          OPEN      PMSVX1A1,"pmsvx1af"
.
          DISPLAY   *P72:24,"patpramf";
          OPEN      PATPR1A1,"patpr1af"
          OPEN      PATPX1A1,"patpx1af"
.
          OPEN      CONTROLF,"controlf"
          OPEN      PATGSRN1,"patgsrnf"          * open Patient Surname file
          OPEN      PATGSRN2,"patgsrnf"          * open Patient Surname file
.
...          DISPLAY   *P72:24,"pridebtf";
...          OPEN      PRIDEBT1,"pridebtf"
...          OPEN      PRIDEBT2,"pridebtf"
.
          DISPLAY   *P72:24,"pridoctf";
          OPEN      PRIDOCT1,"pridoctf"
.
          DISPLAY   *P72:24,"pridtraf";
          OPEN      PRIDTRA1,"pridtraf"
.
          DISPLAY   *P72:24,"prihdbtf";
          OPEN      PRIHDBT1,"prihdbtf"
          OPEN      PRIHDBT2,"prihdbtf"
.
          DISPLAY   *P72:24,"prihreff";
          OPEN      PRIHREF1,"prihreff"
.
          DISPLAY   *P72:24,"prihtraf";
          OPEN      PRIHTRA1,"prihtraf"
.
          DISPLAY   *P72:24,"priinvof";
          OPEN      PRIINVO1,"priinvof"
.
          dISPLAY   *P72:24,"priletaf";
          OPEN      PRILETR1,"priletaf"
          OPEN      PRILETR2,"priletaf"
.
          DISPLAY   *P72:24,"pripracf";
          OPEN      PRIPRAC1,"pripracf"
.
          DISPLAY   *P72:24,"controlf";
          OPEN      CONTROLF,"controlf"
          READ      CONTROLF,THIRTY3;*124,PRCNUDF1,*126,PRCNUDF2,*128,PRCNUDF3:
                                     *130,PRCNUDF4,*132,PRCNUDF5,*134,PRCNUDF6:
                                     *136,PRCNUDF7,*138,PRCNUDF8,*200,PRCNRDOC
          MOVE      ONE,CNEWDS
.
. -----   Set up Port Dependant Temp File  -----
.
          CLEAR     FNAMER
          APPEND    "pritm1",FNAMER
          APPEND    PORT,FNAMER
          RESET     FNAMER
          REPLACE   " 0",FNAMER
.
          MOVE      TWO,PACFRMT
.
          MATCH     "IBARSH",PGM
          GOTO      INIT9999 IF NOT EQUAL
.
          DISPLAY   *P72:24,"priglsaf";
          OPEN      PRIGLSA1,"priglsaf"
.
          DISPLAY   *P72:24,"prigslaf";
          OPEN      PRIGSLA1,"prigslaf"
.
INIT9999  RETURN
+
.********************************************************************** 
.*                            OPTN0000                                *
.*                      Main Option Screen                            *
.********************************************************************** 
OPTN0000  DISPLAY   *P1:3,*EF:
                    *P1:4,*V2LON," 0",*HOFF," = Exit":
                    *P1:5,*V2LON," 1",*HOFF," = Print Inpatient Letters":
                    *P1:7,"Select Option : ";
.
.------ keyin the option ------
.
OPTN1000  KEYIN     *P17:7,*DV,UNDLN1,*P17:7,*V2LON,OPTION;
.
          COMPARE   ZERO,OPTION             * see if exit chosen
          GOTO      OPTN9000 IF EQUAL
.
          BRANCH    OPTION,OPTN2000         * skip if a valid option
.
          BEEP                              * invalid option chosen
.
          GOTO      OPTN1000
.
.------ we have a valid option ------
.
OPTN2000  MOVE      FALSE,EXIT
.
          GOTO      OPTN9999
.
.------ Exit chosen ------
.
OPTN9000  MOVE      TRUE,EXIT
.
OPTN9999  RETURN
+
.**********************************************************************
.*                            OPTW0000                                *
.*                  Main Option Screen for Web                        *
.**********************************************************************
.
OPTW0000  DISPLAY   *P1:3,*EF:
                    *P1:4,*V2LON,"0",*HOFF," = Exit":
                    *P1:5,*V2LON,"1",*HOFF," = Select Inpatients":
                    *P1:6,*V2LON,"2",*HOFF," = Print Inpatient Letters":
                    *P1:7,*V2LON,"3",*HOFF," = Delete Selected Patients":
                    *P1:9,"Select Option : ";
.
OPTW1000  KEYIN     *P17:9,*DV,UNDLN1,*P17:9,*V2LON,OPTION;
.
          COMPARE   ZERO,OPTION
          GOTO      OPTW9000 IF EQUAL
.
          BRANCH    OPTION,OPTW2000,OPTW2000,OPTW2000
.
          BEEP
          GOTO      OPTW1000
.
OPTW2000  MOVE      FALSE,EXIT
          GOTO      OPTW9999
.
OPTW9000  MOVE      TRUE,EXIT
.
OPTW9999  RETURN
.
.********************************************************************** 
.*                            CLR0000                                 *
.*                         Clear Routine                              *
.********************************************************************** 
CLR0000   UNPACK    SP30,TDADCL1,TDADCL2,TDADTY1,TDADTY2,TDCLAM1
          UNPACK    SP30,TDCLAM2,TDCOBT1,TDCOBT2,TDCRCL1,TDCRCL2
          UNPACK    SP30,TDDSST1,TDDSST2,TDHTFD1,TDHTFD2,TDRELG1
          UNPACK    SP30,TDMEMB,TDDCST,TDRELG2,TDRFSC1,TDRFSC2
          UNPACK    SP30,TDSURN1
          UNPACK    SP30,TDSURN2
          UNPACK    SP30,SNUMB,ENUMB,DEBTNO,MPRAC
          UNPACK    SP30,SPRAC,EPRAC,DOCTOR,SDOCT,EDOCT
          UNPACK    SP30,TDURNO1,TDURNO2
          UNPACK    SP30,TD1UDF1,TD2UDF1,TD3UDF1,TD4UDF1,TD5UDF1
          UNPACK    SP30,TD1UDF2,TD2UDF2,TD3UDF2,TD4UDF2,TD5UDF2
          UNPACK    SP30,TD6UDF1,TD7UDF1,TD8UDF1
          UNPACK    SP30,TD6UDF2,TD7UDF2,TD8UDF2
.
          UNPACK    SP30,TVADCL1,TVADCL2,TVVIST1,TVVIST2,TVADTY1,TVADTY2
          UNPACK    SP30,TVCLAM1,TVCLAM2,TVCOBT1,TVCOBT2,TVCRCL1,TVCRCL2
          UNPACK    SP30,TVDCST,TVDSDT1,TVDSDT2,TVDSST1,TVDSST2,TVHTFD1
          UNPACK    SP30,TVHTFD2,TVMEMB,TVRELG1,TVRELG2,TVRFSC1,TVRFSC2
          UNPACK    SP30,TVSURN1
          UNPACK    SP30,TVSURN2
          UNPACK    SP30,TV1UDF1,TV2UDF1,TV3UDF1,TV4UDF1
          UNPACK    SP30,TV5UDF1,TV1UDF2,TV2UDF2,TV3UDF2,TV4UDF2,TV5UDF2
          UNPACK    SP30,TV6UDF1,TV7UDF1,TV8UDF1
          UNPACK    SP30,TV6UDF2,TV7UDF2,TV8UDF2
.
          MOVE      ZERO,TVURNO1
          MOVE      ZERO,TVURNO2
.
          MOVE      ZERO,FLAGDEBT
          MOVE      ZERO,FLAGSURN
          MOVE      ZERO,FLAGVIST
          MOVE      ZERO,FLAGPRAC
          MOVE      ZERO,FLAGSDOC
          MOVE      ZERO,FLAGCLAM
          MOVE      ZERO,FLAGUDF1
          MOVE      ZERO,FLAGUDF2
          MOVE      ZERO,FLAGUDF3
          MOVE      ZERO,FLAGUDF4
          MOVE      ZERO,FLAGUDF5
          MOVE      ZERO,FLAGUDF6
          MOVE      ZERO,FLAGUDF7
          MOVE      ZERO,FLAGUDF8
          MOVE      ZERO,FLAGURNO
          MOVE      TRUE,FLAGALL
.
CLR9999   RETURN
+
.********************************************************************** 
.*                            SCRN0000                                *
.*                       Main Adhoc Screen                            *
.********************************************************************** 
SCRN0000  DISPLAY   *P1:3,*EF:
                    *P1:4,*V2LON," 1",*HOFF,". Debtor Numbers       : ":
                    *P1:5,*V2LON," 2",*HOFF,". Surnames             : ":
                    *P1:6,*V2LON," 3",*HOFF,". Visit Dates          : ":
                    *P1:7,*V2LON," 4",*HOFF,". Practices            : ":
                    *P1:8,*V2LON," 5",*HOFF,". Service Doctors      : ":
                    *P1:9,*V2LON," 6",*HOFF,". Claim Codes          : ";
.
          MOVE      TEN,SCRNPOS  
          MOVE      SEVEN,OPTNNUMB
          MOVE      ONE,COUNT
.
.------ get the next user defined field to process ------
.
SCRN1000  LOAD      FORM1,COUNT,PRCNUDF1,PRCNUDF2,PRCNUDF3,PRCNUDF4,PRCNUDF5:
                                PRCNUDF6,PRCNUDF7,PRCNUDF8
          LOAD      CODE,COUNT,CODEG1,CODEG2,CODEG3,CODEG4,CODEG5,CODEG6:
                               CODEG7,CODEG8
.
          COMPARE   ZERO,FORM1              * skip if user defined field
          GOTO      SCRN1500 IF EQUAL         is not being used
.
          MOVE      "Unknown Description",TDESC
          PACK      KEY5,CODE,SP3
          CALL      RDCODE1                 * read the patient codes file
.
          DISPLAY   *P1:SCRNPOS,*V2LON,OPTNNUMB,*HOFF,". ",TDESC," : ";
          ADD       ONE,SCRNPOS
          ADD       ONE,OPTNNUMB
.
.------ increment the counter and see if we have finished ------
.
SCRN1500  ADD       ONE,COUNT
.
          COMPARE   FIVE,COUNT              * see if we have finished
          GOTO      SCRN9999 IF EQUAL
.
          GOTO      SCRN1000
.
SCRN9999  RETURN
+
.********************************************************************** 
.*                            SEL0000                                 *
.*                       Select Item Routine                          *
.********************************************************************** 
SEL0000   DISPLAY   *P1:24,*EL,"Select Item, (",*V2LON,ANSP,*HOFF:
                               ")rocess, (",*V2LON,ANSC,*HOFF:
                               ")ancel, (",*V2LON,ANSE,*HOFF:
                               ")xit ? ";
.
.------ select an option ------
.
SEL1000   KEYIN     *P44:24,*DV,UNDLN2,*P44:24,*V2LON,*JR,DIMOPTN;
.
          RESET     DIMOPTN                 * see if something is entered
          GOTO      SEL1000 IF EOS
.
          REP       UPPLOW,DIMOPTN
.
          MATCH     " P",DIMOPTN            * see if process was entered
          GOTO      SEL7000 IF EQUAL
.
          MATCH     " C",DIMOPTN            * see if cancel was entered
          GOTO      SEL8000 IF EQUAL
.
          MATCH     " E",DIMOPTN            * see if exit was entered
          GOTO      SEL9000 IF EQUAL
.
          TYPE      DIMOPTN                 * Ensure option keyed is numeric
          GOTO      SEL1900 IF NOT EQUAL
.
          MOVE      DIMOPTN,OPTION          * Get a form field
.
          COMPARE   ONE,OPTION              * check option > 0
          GOTO      SEL1900 IF LESS
.
          COMPARE   OPTNNUMB,OPTION         * Check for max fields
          GOTO      SEL1900 IF NOT LESS     
.
          MOVE      FALSE,EXIT
.
          GOTO      SEL9999
.
.------ invalid option chosen ------
.
SEL1900   BEEP
          GOTO      SEL1000
.
.------ Process was entered ------
.
SEL7000   MOVE      TWO,EXIT
.
          GOTO      SEL9999
.
.------ cancel was entered ------
.
SEL8000   CALL      SCRN0000                * Display Adhoc Screen
.
          CALL      CLR0000                 * Clear Variables
.
          GOTO      SEL0000
.
.------ exit was entered ------
.
SEL9000   MOVE      TRUE,EXIT
.
SEL9999   RETURN
+
.**********************************************************************
.*                            SELW0000                                *
.*                      Read Web Range Parameters                     *
.**********************************************************************
.
SELW0000  DISPLAY   *P1:3,*EF:
                    *P1:9,*V2LON,"Enter Selection ID :"
.
SELW1000  KEYIN     *P22:9,*DV,UNDLN1,*P22:9,*V2LON,SELECTID;
.
          MATCH     SP70,SELECTID
          GOTO      SELW9000 IF EQUAL
.
          PACK      KEY4,SELECTID,SP70
          CALL      RDPRGLS1
          IF        OVRCD = 0
            GOTO      SELW2000
          ENDIF
.
          BEEP
          GOTO      SELW1000
.
SELW2000  MOVE      FALSE,EXIT
          GOTO      SELW9999
.
SELW9000  MOVE      TRUE,EXIT
.
SELW9999  RETURN
+
.**********************************************************************
.*                            DELW0000                                *
.*  Remove all selected patients from selection file for web          *
.**********************************************************************
DELW0000  PACK      KEY22,SELECTID,SP70
          CALL      RSPRGSL1
          CALL      RKPRGSL1
          BRANCH    OVRCD,DELW9999
.
          MATCH     SELECTID,PRGSSEID
          GOTO      DELW9999 IF NOT EQUAL
.
          PACK      KEY22,PRGSSEID,PRGSDEBT,PRGSSCAN,PRGSUNIQ,SP70
          CALL      DEPRGSL1
          GOTO      DELW0000
.
DELW9999  RETURN
.
.**********************************************************************
.*                            SETW0000                                *
.* Set up selection variables from the selection id file for web      *
.**********************************************************************
SETW0000  MOVE      ZERO,VSCANPMI
.
          MATCH     "1",PRGLSCAN
          GOTO      SETW1000 IF EQUAL
.
          MATCH     SP70,PRGLDBFR
          IF        !@EQUAL
            MOVE      TRUE,FLAGDEBT
            MOVE      PRGLDBFR,SNUMB
          ENDIF
.
          MATCH     SP70,PRGLDBTO
          IF        !@EQUAL
            MOVE      TRUE,FLAGDEBT
            MOVE      PRGLDBTO,ENUMB
          ENDIF
          GOTO      SETW2000
.
SETW1000  MATCH     SP70,PRGLDBFR
          IF        !@EQUAL
            MOVE      TRUE,FLAGURNO
            MOVE      PRGLDBFR,SNUMB
          ENDIF
.
          MATCH     SP70,PRGLDBTO
          IF        !@EQUAL
            MOVE      TRUE,FLAGURNO
            MOVE      PRGLDBTO,ENUMB
          ENDIF
          MOVE      ONE,VSCANPMI
.
SETW2000  COMPARE   TRUE,FLAGDEBT
          IF        @EQUAL
            MOVE      FALSE,FLAGALL
          ENDIF
.
          COMPARE   TRUE,FLAGURNO
          IF        @EQUAL
            MOVE      FALSE,FLAGALL
          ENDIF
.
          MATCH     SP70,PRGLSNFR
          IF        !@EQUAL
            MOVE      TRUE,FLAGSURN
            MOVE      PRGLSNFR,TVSURN1
            STRIP     TVSURN1
          ENDIF
.
          MATCH     SP70,PRGLSNTO
          IF        !@EQUAL
            MOVE      TRUE,FLAGSURN
            MOVE      PRGLSNTO,TVSURN2
            STRIP     TVSURN2
          ENDIF
.
          MATCH     SP70,PRGLVDFR
          IF        !@EQUAL
            MOVE      TRUE,FLAGVIST
            MOVE      PRGLVDFR,TVVIST1
          ENDIF
.
          MATCH     SP70,PRGLVDTO
          IF        !@EQUAL
            MOVE      TRUE,FLAGVIST
            MOVE      PRGLVDTO,TVVIST2
          ENDIF
.
          MATCH     SP70,PRGLPPFR
          IF        !@EQUAL
            MOVE      TRUE,FLAGPRAC
            MOVE      PRGLPPFR,SPRAC
          ENDIF
.
          MATCH     SP70,PRGLPPTO
          IF        !@EQUAL
            MOVE      TRUE,FLAGPRAC
            MOVE      PRGLPPTO,EPRAC
          ENDIF
.
          MATCH     SP70,PRGLSDFR
          IF        !@EQUAL
            MOVE      TRUE,FLAGSDOC
            MOVE      PRGLSDFR,SDOCT
          ENDIF
.
          MATCH     SP70,PRGLSDTO
          IF        !@EQUAL
            MOVE      TRUE,FLAGSDOC
            MOVE      PRGLSDTO,EDOCT
          ENDIF
.
          MATCH     SP70,PRGLCCFR
          IF        !@EQUAL
            MOVE      TRUE,FLAGCLAM
            MOVE      PRGLCCFR,TVCLAM1
          ENDIF
.
          MATCH     SP70,PRGLCCTO
          IF        !@EQUAL
            MOVE      TRUE,FLAGCLAM
            MOVE      PRGLCCTO,TVCLAM2
          ENDIF
.
SETW9999  RETURN
.
.**********************************************************************
.*                            DSEL0000                                *
.*                                                                    *
.**********************************************************************
.
DSEL0000  DISPLAY   *P1:3,*EF:
                    *P1:9,*V2LON,"Enter Selection ID :"
.
DSEL1000  KEYIN     *P22:9,*DV,UNDLN1,*P22:9,*V2LON,SELECTID;
.
          MATCH     SP70,SELECTID
          GOTO      DSEL9000 IF EQUAL
.
DSEL2000  MOVE      FALSE,EXIT
          GOTO      DSEL9999
.
DSEL9000  MOVE      TRUE,EXIT
.
DSEL9999  RETURN
.
.**********************************************************************
.*                            SENW0000                                *
.*                    Send Letter to Patients                         *
.**********************************************************************
SENW0000  CALL      LETT0000                * Keyin Letter Number to Send
          BRANCH    EXIT,SENW9000
.
SENW1000  CALL      DATE0000                * Keyin Letter Date
.
          CALL      PRNW0000                * Print Patient Letters
.
SENW9000  MOVE      TRUE,EXIT
          GOTO      SENW9999
.
SENW9500  MOVE      FALSE,EXIT
          GOTO      SENW9999
.
SENW9999  RETURN
.
.**********************************************************************
.*                           DEBT0000                                 *
.*               Input ID numbers - either U/R or Debtor              *
.**********************************************************************
DEBT0000  MOVE      TRUE,FLAGDEBT
          MOVE      TRUE,FLAGURNO
          MOVE      TRUE,FLAGALL
          MOVE      ZERO,SSCREEN
          MOVE      SP8,SNUMB
          MOVE      START,DDEBT1
          MOVE      "28",CCOL
          MOVE      FOUR,CVERT
          DISPLAY   *P28:4,*EL;
.
          CALL      GETSCR00                * get the screen
.
          CALL      PRIKYDEB                * keyin Debtor/UR number
          COMPARE   ZERO,OVRCD
          GOTO      DEBT0100 IF EQUAL
.
          MOVE      FALSE,FLAGDEBT
          MOVE      FALSE,FLAGURNO
          MOVE      TRUE,FLAGALL
.
          GOTO      DEBT0500
.
.------ a number was entered ------
.
DEBT0100  MOVE      VDEBTOR,SNUMB
          MOVE      VDEBTOR,DDEBT1
.
          BRANCH    VSCANPMI,DEBT0200       * skip if a U/R number
.
          MOVE      FALSE,FLAGALL
          MOVE      FALSE,FLAGURNO
.
          GOTO      DEBT0500
.
.------ Flag U/R number keyed in ------
.
DEBT0200  MOVE      FALSE,FLAGDEBT
          MOVE      FALSE,FLAGALL
.
.------ see if we need to re-display the screen ------
.
DEBT0500  BRANCH    SSCREEN,DEBT0550
.
          CALL      FRESCR00                * free the screen
.
          GOTO      DEBT1000
.
.------ re-display the screen ------
.
DEBT0550  CALL      PUTSCR00
.
.------ display the first debtor number ------
.
DEBT1000  DISPLAY   *P28:4,*EL,*V2LON,DDEBT1;
.
.------ Keyin second Debtor/UR number ------
.
DEBT1100  MOVE      FINISH,DDEBT2
          MOVE      "99999999",ENUMB
          DISPLAY   *P37:4,*EL,"to ";
          MOVE      "40",CCOL
          MOVE      FOUR,CVERT
.
          CALL      GETSCR00                * get the current screen
.
          CALL      PRIKYDEB                * keyin Debtor/UR number
.
          BRANCH    SSCREEN,DEBT1150        * see if we need to re-display the
.                                             screen
          CALL      FRESCR00                * free the current screen
.
          GOTO      DEBT1170
.
.------ put the screen back ------
.
DEBT1150  CALL      PUTSCR00
.
.------ see if a number was entered ------
.
DEBT1170  BRANCH    OVRCD,DEBT2000
.
          MOVE      VDEBTOR,ENUMB
          MOVE      VDEBTOR,DDEBT2
.
          BRANCH    VSCANPMI,DEBT1500       * skip if a U/R
.
          BRANCH    FLAGURNO,DEBT8500       * skip if the first number was a 
.                                             U/R number
          MATCH     SNUMB,ENUMB             * match debtor numbers
          GOTO      DEBT8000 IF LESS
.
          MOVE      FALSE,FLAGALL
          MOVE      TRUE,FLAGDEBT
.
          GOTO      DEBT2000
.
.------ U/R entered as second number ------
.
DEBT1500  BRANCH    FLAGDEBT,DEBT8500       * skip if a Debtor number
.
          MATCH     SNUMB,ENUMB             * match U/R numbers
          GOTO      DEBT8000 IF LESS
.
          MOVE      FALSE,FLAGALL
          MOVE      TRUE,FLAGURNO
.
.------ display the second debtor number ------
.
DEBT2000  DISPLAY   *P40:4,*EL,*V2LON,DDEBT2;
.
          GOTO      DEBT9999
.
.------ invalid range entered ------
.
DEBT8000  BRANCH    FLAGURNO,DEBT8050               * branch on U/R flag
.
          DISPLAY   *P1:24,*EL,*B,"Invalid debtor number range - Hit<",*V2LON:
                                  "ENTER",*HOFF,">";
          KEYIN     ANS;
          DISPLAY   *P1:24,*EL;
.
          GOTO      DEBT1100
.
.------ invalid U/R range entered ------
.
DEBT8050  DISPLAY   *P1:24,*EL,*B,"Invalid U/R number range - Hit<",*V2LON:
                                  "ENTER",*HOFF,">";
          KEYIN     ANS;
          DISPLAY   *P1:24,*EL;
.
          GOTO      DEBT1100
.
.------ Range is a mixture of Debtor and U/R Numbers ------
.
DEBT8500  DISPLAY   *P1:24,*EL,*B,"You cannot mix U/R Numbers and Debtor":
                    " Numbers - Hit<",*V2LON,"ENTER",*HOFF,">";
          KEYIN     ANS;
          DISPLAY   *P1:24,*EL;
.
          GOTO      DEBT1100
.
DEBT9999  RETURN
+
.********************************************************************** 
.*                            SURN0000                                *
.*                      Input Surname Range                           *
.********************************************************************** 
SURN0000  MOVE      TRUE,FLAGSURN
          DISPLAY   *P28:5,*EL,UNDLN20;
          KEYIN     *P28:5,*V2LON,TVSURN1;
.
          RESET     TVSURN1                 * see if a surname was entered
          GOTO      SURN1000 IF EOS
.
          MOVE      TVSURN1,TDSURN1
.
          GOTO      SURN5000
.
.------ no surname was entered ------
.
SURN1000  MOVE      START,TDSURN1
          MOVE      SP20,TVSURN1
.
.------ display the first surname details ------
.
SURN5000  DISPLAY   *P28:5,*V2LON,TDSURN1;
.
.------ keyin the second surname ------
.
SURN5100  DISPLAY   *P49:5,"to ":
                    *P52:5,UNDLN20;
.
          KEYIN     *P52:5,*V2LON,TVSURN2;
.
          RESET     TVSURN2                 * see if a surname was entered
          GOTO      SURN6000 IF EOS
.
          MOVE      TVSURN2,TDSURN2
.
          MATCH     TVSURN1,TVSURN2         * match surnames
          GOTO      SURN9999 IF NOT LESS
.
          DISPLAY   *P1:24,*EL,*B,"Invalid surname range - Hit <":
                           *V2LON,"ENTER",*HOFF,"> to continue";
          KEYIN     ANS;
          DISPLAY   *P1:24,*EL;
.
          GOTO      SURN5100
.
.------ no second surname was entered ------
.
SURN6000  MOVE      FINISH,TDSURN2
          MOVE      ZEDS,TVSURN2
.
.------ display the surname details ------
.
SURN9999  DISPLAY   *P52:5,*V2LON,TDSURN2;
          RETURN
+
.********************************************************************** 
.*                            VIST0000                                *
.*                   Input Visit Date Range                           *
.********************************************************************** 
VIST0000  MOVE      TRUE,FLAGVIST
.
          UNPACK    SP6,CDAY,CMON,CYEAR
          MOVE      CCC,CCENT
          REP       " 0",CCENT
          MOVE      TWENTY8,CCOL
          MOVE      SIX,CVERT
          MOVE      ZERO,CCANLDTE
          MOVE      ZERO,CHIGHLT
.
.------ keyin the first date ------
.
VIST0500  CALL      KEYDATE
.
          BRANCH    CQUEST,VIST0500
          BRANCH    OVRCD,VIST1000
.
          CALL      PACDATE                 * pack the date
.
          MOVE      CPCDATE,TDVIST1
          PACK      TVVIST1,CCENT,CYEAR,CMON,CDAY
.
          GOTO      VIST5000
.
.------ no date was entered ------
.
VIST1000  MOVE      SP8,TVVIST1
          MOVE      START,TDVIST1
.
.------ display the date details ------
.
VIST5000  DISPLAY   *P28:6,*V2LON,TDVIST1;
.
.------ keyin the second date ------
.
VIST5100  DISPLAY   *P39:6,*EL,"to ";
          UNPACK    SP6,CDAY,CMON,CYEAR
          MOVE      CCC,CCENT
          REP       " 0",CCENT
          MOVE      FORTY2,CCOL
          MOVE      SIX,CVERT
          MOVE      ZERO,CCANLDTE
          MOVE      ZERO,CHIGHLT
.
.------ keyin the date ------
.
VIST5500  CALL      KEYDATE
.
          BRANCH    CQUEST,VIST5500
          BRANCH    OVRCD,VIST6000          * see if a date was entered
.
          CALL      PACDATE                 * pack the date
.
          MOVE      CPCDATE,TDVIST2
          PACK      TVVIST2,CCENT,CYEAR,CMON,CDAY
.
          MATCH     TVVIST1,TVVIST2         * match the visit dates
          GOTO      VIST9999 IF NOT LESS
.
          DISPLAY   *P1:24,*EL,*B,"Invalid visit date range - Hit <":
                           *V2LON,"ENTER",*HOFF,"> to continue";
          KEYIN     ANS;
          DISPLAY   *P1:24,*EL;
.
          GOTO      VIST5100
.
.------ no second visit date was entered ------
.
VIST6000  MOVE      "99999999",TVVIST2
          MOVE      FINISH,TDVIST2
.
.------ display the visit date details ------
.
VIST9999  DISPLAY   *P42:6,*V2LON,TDVIST2;
          RETURN
+
.****************************************************************************
.*                              SPRA0000               Called by: ML0000    *
.*                 get the starting medical practice                        *
.****************************************************************************
SPRA0000  MOVE      TRUE,FLAGPRAC
          DISPLAY   *P28:7,UNDLN6;
          KEYIN     *P28:7,*V2LON,MPRAC;
.
          CALL      CHKP0000                * see what was entered
          BRANCH    EXIT,SPRA9900:          * exitchar entered
                         SPRA4000:          * ? entered
                         SPRA9000:          * valid M.P.
                         SPRA8000           * nothing entered
.
          GOTO      SPRA0000                * invalid M.P.
.
.------ ? entered ------
.
SPRA4000  MOVE      ZERO,HLEF
.
          CALL      GETSCR00                * save the screen
.
.------ display all the medical practices ------
.
SPRA4200  CALL      PRIPRADS                * list M.P.'s on file
          BRANCH    OVRCD,SPRA9800
.
.------ keyin the medical practice ------
.
SPRA4500  KEYIN     *P1:24,*EL,"From Medical Practice : ",*DV,UNDLN6:
                    *P25:24,*V2LON,MPRAC;
.         
          CALL      CHKP0000                * see what was entered
          BRANCH    EXIT,SPRA9800:          * exitchar entered
                         SPRA4200:          * ? entered
                         SPRA8900:          * valid M.P. number
                         SPRA7900           * nothing entered
.
          GOTO      SPRA4500                * invalid M.P.
.
.------ re-display the screen ------
.
SPRA7900  CALL      PUTSCR00                * restore screen
.
.------ no practice was entered ------
.
SPRA8000  DISPLAY   *P28:7,*EL,*V2LON,START;
.
          GOTO      SPRA9500
.
.------ re-display the screen ------
.
SPRA8900  CALL      PUTSCR00                * restore screen
.
.------ display the practice ------
.
SPRA9000  DISPLAY   *P28:7,*EL,*V2LON,MPRAC;
.
.------ set the the starting practice and exit ------
.
SPRA9500  MOVE      MPRAC,SPRAC
          MOVE      ZERO,EXIT
.
          GOTO      SPRA9999
.
.------ we have no practices on file OR Exitchar was entered ------
.
SPRA9800  CALL      PUTSCR00                * put back the screen
.
.------ Exitchar was entered ------
.
SPRA9900  MOVE      ONE,EXIT
          MOVE      FALSE,FLAGPRAC
          DISPLAY   *P28:7,*EL;
.
SPRA9999  RETURN
+ 
.**************************************************************************
.*                                  CHKP0000           Called by: SMPR0000*
.*                         See if anything entered                EMPR0000*
.*         Exit - 0 = invalid entry                                       *
.*                1 = nothing/exitchar entered                            *
.*                2 = ? entered                                           *
.*                3 = valid medical practice
.**************************************************************************
CHKP0000  ENDSET    MPRAC
          APPEND    SP6,MPRAC
          RESET     MPRAC
.
          MATCH     SP6,MPRAC               * anything entered ?
          GOTO      CHKP9500 IF EQUAL       * no
.
          MATCH     EXITCHAR,MPRAC          * exitchar entered ?
          GOTO      CHKP7000 IF EQUAL       * yes
.
          MATCH     QUEST,MPRAC             * ? entered ?
          GOTO      CHKP8000 IF EQUAL       * yes
.
.         Medical Practice code entered
.
          MOVE      MPRAC,KEY6
          CALL      RDPRPR1                  * read the medical practice file
.
          COMPARE   ZERO,OVRCD               * see if on file
          GOTO      CHKP9000 IF EQUAL
.
          DISPLAY   *P1:24,*EL,*B,"Medical Practice not on file. ";
          CALL      HITENTER
.
          MOVE      ZERO,EXIT               
.
          GOTO      CHKP9999
.
.------ Exitchar was entered ------
.
CHKP7000  MOVE      ONE,EXIT                
.
          GOTO      CHKP9999
.
.------ ? was entered ------
.
CHKP8000  MOVE      TWO,EXIT               
.
          GOTO      CHKP9999
.
.------ we have a valid practice ------
.
CHKP9000  MOVE      THREE,EXIT            
.
          GOTO      CHKP9999
.
.------ no medical practice was entered ------
.
CHKP9500  MOVE      FOUR,EXIT            
.
CHKP9999  RETURN
+
.****************************************************************************
.*                              EPRA0000               Called by: ML0000    *
.*                 get the ending medical practice code                     *
.****************************************************************************
EPRA0000  DISPLAY   *P35:7,*EL,"to ":
                    *P38:7,UNDLN6;
          KEYIN     *P38:7,*V2LON,MPRAC;
.
          CALL      CHKP0000                 * see what was entered
          BRANCH    EXIT,EPRA9900:           * exitchar entered
                         EPRA4000:           * ? entered
                         EPRA9000:           * valid M.P.
                         EPRA8000            * nothing entered
.
          GOTO      EPRA0000                 * invalid M.P.
.
.------ ? was entered ------
.
EPRA4000  MOVE      ZERO,HLEF
.
          CALL      GETSCR00                 * save the screen
.
.------ display all of the medical practices ------
.
EPRA4200  CALL      PRIPRADS                 * list M.P.'s on file
          BRANCH    OVRCD,EPRA9800
.
.------ keyin the medical practice ------
.
EPRA4500  KEYIN     *P1:24,*EL,"To Medical Practice : ",*DV,UNDLN6:
                    *P23:24,*V2LON,MPRAC;
.         
          CALL      CHKP0000                 * see what was entered
          BRANCH    EXIT,EPRA9800:           * exitchar entered
                         EPRA4200:           * ? entered
                         EPRA8900:           * valid M.P.
                         EPRA7900            * nothing entered
.
          GOTO      EPRA4500                 * invalid M.P.
.
.------ re-display the screen ------
.
EPRA7900  CALL      PUTSCR00                 * restore screen
.
.------ no medical practice was entered ------
.
EPRA8000  MOVE      ZED6,MPRAC
          DISPLAY   *P38:7,*EL,*V2LON,FINISH;
.
          GOTO      EPRA9500
.
.------ re-display the screen ------
.
EPRA8900  CALL      PUTSCR00                 * restore screen
.
.------ match medical practices ------
.
EPRA9000  MATCH     SPRAC,MPRAC              * start number > end number ?
          GOTO      EPRA9200 IF NOT LESS     * no
.
          DISPLAY   *P38:7,*EL,*V2LON,MPRAC,*HOFF:
                    *P1:24,*EL,*B,"Invalid practice range.  ";
          CALL      HITENTER
.
          GOTO      EPRA0000
.
.------ display the practice ------
.
EPRA9200  DISPLAY   *P38:7,*EL,*V2LON,MPRAC;
.
.------ set up the end practice ------
.
EPRA9500  MOVE      MPRAC,EPRAC
          MOVE      ZERO,EXIT
.
          GOTO      EPRA9999
.
.------ no practices on file OR Exitchar was entered ------
.
EPRA9800  CALL      PUTSCR00                * restore the screen
.
.------ Exitchar was entered ------
.
EPRA9900  MOVE      ONE,EXIT
          MOVE      FALSE,FLAGPRAC
          DISPLAY   *P28:7,*EL;
.
EPRA9999  RETURN
+
.****************************************************************************
.*                                  SDOC0000           Called by: ML0000    *
.*                         get starting doctor                              *
.*         Returns: EXIT  0 = OK                                            *
.*                        1 = exitchar entered                              *
.****************************************************************************
SDOC0000  MOVE      TRUE,FLAGSDOC
          DISPLAY   *P28:8,*EL,*V2LON,UNDLN6;
          MOVE      "28",ECOL
          MOVE      "8",EVERT
          MOVE      SP6,CKYIDEF6
          MOVE      ZERO,CKYIMAND
          MOVE      ONE,CKYINACT
          MOVE      SP6,MPRAC
          CALL      PRIMPDKY                * Keyin the medical practice doctor
          BRANCH    EXIT,SDOC1000,SDOC9500
.
          MOVE      DCODE,SDOCT
          DISPLAY   *P28:8,*EL,*V2LON,SDOCT;
          GOTO      SDOC9000
.
SDOC1000  DISPLAY   *P28:8,*EL,*V2LON,START;
.
SDOC9000  MOVE      ZERO,EXIT
          GOTO      SDOC9999
.
SDOC9500  MOVE      FALSE,FLAGSDOC
          MOVE      ONE,EXIT
SDOC9999  RETURN
+
.****************************************************************************
.*                                  EDOC0000           Called by: ML0000    *
.*                         get ending doctor                                *
.*         Returns: EXIT  0 = OK                                            *
.*                        1 = exitchar entered                              *
.****************************************************************************
EDOC0000  DISPLAY   *P38:8,*EL,"to ",UNDLN6;
          MOVE      "41",ECOL
          MOVE      "8",EVERT
          MOVE      SP6,CKYIDEF6
          MOVE      ZERO,CKYIMAND
          MOVE      ONE,CKYINACT
          MOVE      SP6,MPRAC
          CALL      PRIMPDKY                * Keyin the medical practice doctor
          BRANCH    EXIT,EDOC1000,EDOC9500
.
          MATCH     SDOCT,DCODE
          IF        @LESS
            DISPLAY   *P1:24,*EL,"End Doctor less than Start Doctor.  ";
            CALL      HITENTER
            GOTO      EDOC0000
          ENDIF
.
          MOVE      DCODE,EDOCT
          DISPLAY   *P41:8,*EL,*V2LON,EDOCT;
          GOTO      EDOC9000
.
EDOC1000  MOVE      ZED6,EDOCT
          DISPLAY   *P41:8,*EL,*V2LON,FINISH;
.
EDOC9000  MOVE      ZERO,EXIT
          GOTO      EDOC9999
.
EDOC9500  MOVE      FALSE,FLAGSDOC
          MOVE      ONE,EXIT
EDOC9999  RETURN
+
.********************************************************************** 
.*                            CLAM0000                                *
.*                     Input Claim Code Range                         *
.********************************************************************** 
CLAM0000  MOVE      TRUE,FLAGCLAM           * Set Flag for this Range 
.
          MOVE      SP3,TVCLAM1
          MOVE      SP6,TDCLAM1
          MOVE      TWENTY8,ECOL
          MOVE      NINE,EVERT
          MOVE      CODECL,CODE
          MOVE      SP3,CKYIDEF3
          MOVE      ZERO,CKYIMAND
.
          CALL      PATCODKY                 * Keyin Codes File Field
          BRANCH    EXIT,CLAM1000,CLAM9000   * 1 = Blank , 2 = Exitchar
.
          MOVE      ACODE,TVCLAM1            * Valid Code Entered
          MOVE      ACODE,TDCLAM1            * Code in the Display Variable
.
          GOTO      CLAM5000
.
.------ no claim code was entered ------
.
CLAM1000  MOVE      SP3,TVCLAM1
          MOVE      START,TDCLAM1
.
.------ display the claim code ------
.
CLAM5000  DISPLAY   *PECOL:EVERT,*V2LON,TDCLAM1;
.
.------ keyin the second claim code ------
.
CLAM5100  DISPLAY   *P35:9,*EL,"to ";
.
          MOVE      SP3,TVCLAM2              * Clear To Variables
          MOVE      SP6,TDCLAM2
.
          MOVE      THIRTY8,ECOL             * Parameters for PATCODKY
          MOVE      NINE,EVERT
          MOVE      CODECL,CODE
          MOVE      SP3,CKYIDEF3
          MOVE      ZERO,CKYIMAND
.
          CALL      PATCODKY                 * keyin the codes file entry
          BRANCH    EXIT,CLAM8000,CLAM9000   * 1 = Blank , 2 = Exitchar
.
          MOVE      ACODE,TVCLAM2
          MOVE      ACODE,TDCLAM2
.
          MATCH     TVCLAM1,TVCLAM2          * Check From Date is Not Greater
          GOTO      CLAM9500 IF NOT LESS     * Than the To Date
.
          DISPLAY   *P1:24,*EL,*B,"Invalid code range - Hit <":
                               *V2LON,"ENTER",*HOFF,"> to Continue ";
          KEYIN     *EOFF,ANS;
          DISPLAY   *P1:24,*EL;
.
          GOTO      CLAM5100
.
.------ no second claim code entered ------
.
CLAM8000  MOVE      ZEDS,TVCLAM2            * Set Value to "ZZZ" if <CR>
          MOVE      FINISH,TDCLAM2         * Display 'Finish'
.
          GOTO      CLAM9500
.
.------ Exitchar was entered ------
.
CLAM9000  MOVE      FALSE,FLAGCLAM          * Exitchar so Unset Range Flag
.
          UNPACK    SP6,TVCLAM1,TVCLAM2     * Clear Vorking Variables
          UNPACK    SP12,TDCLAM1,TDCLAM2
.
          DISPLAY   *P28:9,*EL;
.
          GOTO      CLAM9999
.
.------ display the claim details ------
.
CLAM9500  DISPLAY   *PECOL:EVERT,*V2LON,TDCLAM2  * Display the Display Variable
.
CLAM9999  RETURN
+
.********************************************************************** 
.*                            USDF0000                                *
.*                  Process the User Defined Fields                   *
.********************************************************************** 
USDF0000  MOVE      NINE,EVERT
          MOVE      SIX,OPTCOUNT
.
          COMPARE   ONE,PRCNUDF1            * see if we are using the first 
          GOTO      USDF1000 IF NOT EQUAL     user defined field
.
          ADD       ONE,EVERT
          ADD       ONE,OPTCOUNT
.
          COMPARE   OPTCOUNT,OPTION         * see if this was the field 
          GOTO      USDF1000 IF NOT EQUAL     selected
.
          CALL      UDF10000                * Keyin the first user defined
.                                             field range
.------ see if we are processing the second user defined field ------
.
USDF1000  COMPARE   ONE,PRCNUDF2
          GOTO      USDF2000 IF NOT EQUAL
.
          ADD       ONE,EVERT
          ADD       ONE,OPTCOUNT
.
          COMPARE   OPTCOUNT,OPTION         * see if this was the field 
          GOTO      USDF2000 IF NOT EQUAL     selected
.
          CALL      UDF20000                * Keyin the second user defined
.                                             field range
.------ see if we are processing the third user defined field ------
.
USDF2000  COMPARE   ONE,PRCNUDF3
          GOTO      USDF3000 IF NOT EQUAL
.
          ADD       ONE,EVERT
          ADD       ONE,OPTCOUNT
.
          COMPARE   OPTCOUNT,OPTION         * see if this was the field 
          GOTO      USDF3000 IF NOT EQUAL     selected
.
          CALL      UDF30000                * Keyin the third user defined
.                                             field range
.------ see if we are processing the fourth user defined field ------
.
USDF3000  COMPARE   ONE,PRCNUDF4
          GOTO      USDF9999 IF NOT EQUAL
.
          ADD       ONE,EVERT
          ADD       ONE,OPTCOUNT
.
          COMPARE   OPTCOUNT,OPTION         * see if this was the field 
          GOTO      USDF9999 IF NOT EQUAL     selected
.
          CALL      UDF40000                * Keyin the fourth user defined
.                                             field range
          GOTO      USDF9999
.
.------ see if we are processing the fifth user defined field ------
.
USDF4000  COMPARE   ONE,PRCNUDF5
          GOTO      USDF5000 IF NOT EQUAL
.
          ADD       ONE,EVERT
          ADD       ONE,OPTCOUNT
.
          COMPARE   OPTCOUNT,OPTION         * see if this was the field 
          GOTO      USDF5000 IF NOT EQUAL     selected
.
          CALL      UDF50000                * Keyin the fifth user defined 
.                                             field range
.------ see if we are processing the sixth user defined field ------
.
USDF5000  COMPARE   ONE,PRCNUDF6
          GOTO      USDF6000 IF NOT EQUAL
.
          ADD       ONE,EVERT
          ADD       ONE,OPTCOUNT
.
          COMPARE   OPTCOUNT,OPTION         * see if this was the field
          GOTO      USDF6000 IF NOT EQUAL     selected
.
          CALL      UDF60000                * Keyin the sixth user defined
.                                             field range
.------ see if we are processing the seventh user defined field ------
.
USDF6000  COMPARE   ONE,PRCNUDF7
          GOTO      USDF7000 IF NOT EQUAL
.
          ADD       ONE,EVERT
          ADD       ONE,OPTCOUNT
.
          COMPARE   OPTCOUNT,OPTION         * see if this was the field 
          GOTO      USDF7000 IF NOT EQUAL     selected
.
          CALL      UDF70000                * Keyin the seventh user defined
.                                             field range
.------ see if we are processing the eighth user defined field ------
.
USDF7000  COMPARE   ONE,PRCNUDF8
          GOTO      USDF9999 IF NOT EQUAL
.
          ADD       ONE,EVERT
          ADD       ONE,OPTCOUNT
.
          COMPARE   OPTCOUNT,OPTION         * see if this was the field
          GOTO      USDF9999 IF NOT EQUAL     selected
.
          CALL      UDF80000                * Keyin the eighth user defined
.                                             field range
USDF9999  RETURN
+
.********************************************************************** 
.*                            UDF10000                                *
.*                 Keyin the 1st User Defined Field range             *
.********************************************************************** 
UDF10000  MOVE      TRUE,FLAGUDF1           * Set Flag for this Range 
          MOVE      SP3,TV1UDF1             * Clear the From Variables
          MOVE      SP6,TD1UDF1
.
          MOVE      TWENTY8,ECOL
          MOVE      CODEG1,CODE
          MOVE      SP3,CKYIDEF3
          MOVE      ZERO,CKYIMAND
.
          CALL      PATCODKY                * Keyin Codes File Field
          BRANCH    EXIT,UDF11000,UDF19000  * 1 = Blank , 2 = Exitchar
.
          MOVE      ACODE,TV1UDF1           * Valid Code Entered
          MOVE      ACODE,TD1UDF1           * Code in the Display Variable
.
          GOTO      UDF15000
.
.------ no code entered ------
.
UDF11000  MOVE      SP3,TV1UDF1             * Nothing Entered so Start of File
          MOVE      START,TD1UDF1           * Move Start to Display Variable
.
.------ display the first code ------
.
UDF15000  DISPLAY   *PECOL:EVERT,*V2LON,TD1UDF1;
.
.------ keyin the second code ------
.
UDF15100  DISPLAY   *P35:EVERT,*EL,"to ";
.
          MOVE      SP3,TV1UDF2             * Clear To Variables
          MOVE      SP6,TD1UDF2
.
          MOVE      THIRTY8,ECOL
          MOVE      CODEG1,CODE             
          MOVE      SP3,CKYIDEF3
          MOVE      ZERO,CKYIMAND
.
          CALL      PATCODKY
          BRANCH    EXIT,UDF18000,UDF19000  * 1 = Blank , 2 = Exitchar
.
          MOVE      ACODE,TV1UDF2           * Valid Code Entered
          MOVE      ACODE,TD1UDF2           * Code in Display Variable
.
          MATCH     TV1UDF1,TV1UDF2         * Check From Date is Not Greater
          GOTO      UDF19500 IF NOT LESS    * Than the To Date
.
          DISPLAY   *P1:24,*EL,*B,"Invalid code range - Hit <":
                               *V2LON,"ENTER",*HOFF,"> to Continue ";
          KEYIN     *EOFF,ANS;
          DISPLAY   *P1:24,*EL;
.
          GOTO      UDF15100
.
.------ no second code entered ------
.
UDF18000  MOVE      ZEDS,TV1UDF2            * Set Value to "ZZZ" if <CR>
          MOVE      FINISH,TD1UDF2          * Display 'Finish'
.
          GOTO      UDF19500
.
.------ Exitchar was entered ------
.
UDF19000  MOVE      FALSE,FLAGUDF1          * Exitchar so Unset Range Flag
          UNPACK    SP6,TV1UDF1,TV1UDF2     * Clear Vorking Variables
          UNPACK    SP12,TD1UDF1,TD1UDF2
          DISPLAY   *P28:EVERT,*EL;
.
          GOTO      UDF19999
.
.------ display the second code details ------
.
UDF19500  DISPLAY   *PECOL:EVERT,*V2LON,TD1UDF2  * Display the Display Variable
.
UDF19999  RETURN
+
.********************************************************************** 
.*                            UDF20000                                *
.*                  Keyin the 2nd User Defined Field range            *
.********************************************************************** 
UDF20000  MOVE      TRUE,FLAGUDF2           * Set Flag for this Range 
          MOVE      SP3,TV2UDF1             * Clear the From Variables
          MOVE      SP6,TD2UDF1
          MOVE      TWENTY8,ECOL
          MOVE      CODEG2,CODE
          MOVE      SP3,CKYIDEF3
          MOVE      ZERO,CKYIMAND
.
          CALL      PATCODKY                * Keyin Codes File Field
          BRANCH    EXIT,UDF21000,UDF29000  * 1 = Blank , 2 = Exitchar
.
          MOVE      ACODE,TV2UDF1           * Valid Code Entered
          MOVE      ACODE,TD2UDF1           * Code in the Display Variable
.
          GOTO      UDF25000
.
.------ no code entered ------
.
UDF21000  MOVE      SP3,TV2UDF1             * Nothing Entered so Start of File
          MOVE      START,TD2UDF1           * Move Start to Display Variable
.
.------ display the first code details ------
.
UDF25000  DISPLAY   *PECOL:EVERT,*V2LON,TD2UDF1;
.
.------ keyin the second code ------
.
UDF25100  DISPLAY   *P35:EVERT,*EL,"to ";
.
          MOVE      SP3,TV2UDF2             * Clear To Variables
          MOVE      SP6,TD2UDF2
          MOVE      THIRTY8,ECOL
          MOVE      CODEG2,CODE             
          MOVE      SP3,CKYIDEF3
          MOVE      ZERO,CKYIMAND
.
          CALL      PATCODKY
          BRANCH    EXIT,UDF28000,UDF29000  * 1 = Blank , 2 = Exitchar
.
          MOVE      ACODE,TV2UDF2           * Valid Code Entered
          MOVE      ACODE,TD2UDF2           * Code in Display Variable
.
          MATCH     TV2UDF1,TV2UDF2         * Check From Date is Not Greater
          GOTO      UDF29500 IF NOT LESS    * Than the To Date
.
          DISPLAY   *P1:24,*EL,*B,"Invalid code range - Hit <":
                               *V2LON,"ENTER",*HOFF,"> to Continue ";
          KEYIN     *EOFF,ANS;
          DISPLAY   *P1:24,*EL;
.
          GOTO      UDF25100
.
.------ no second code entered ------
.
UDF28000  MOVE      ZEDS,TV2UDF2            * Set Value to "ZZZ" if <CR>
          MOVE      FINISH,TD2UDF2          * Display 'Finish'
.
          GOTO      UDF29500
.
.------ Exitchar was entered ------
.
UDF29000  MOVE      FALSE,FLAGUDF2          * Exitchar so Unset Range Flag
          UNPACK    SP6,TV2UDF1,TV2UDF2     * Clear Vorking Variables
          UNPACK    SP12,TD2UDF1,TD2UDF2
          DISPLAY   *P28:EVERT,*EL;
.
          GOTO      UDF29999
.
.------ display the second code ------
.
UDF29500  DISPLAY   *PECOL:EVERT,*V2LON,TD2UDF2
.
UDF29999  RETURN
+
.********************************************************************** 
.*                            UDF30000                                *
.*                  Keyin the 3rd User Defined Field range            *
.********************************************************************** 
UDF30000  MOVE      TRUE,FLAGUDF3           * Set Flag for this Range 
          MOVE      SP3,TV3UDF1             * Clear the From Variables
          MOVE      SP6,TD3UDF1
          MOVE      TWENTY8,ECOL
          MOVE      CODEG3,CODE             
          MOVE      SP3,CKYIDEF3
          MOVE      ZERO,CKYIMAND
.
          CALL      PATCODKY                * Keyin Codes File Field
          BRANCH    EXIT,UDF31000,UDF39000  * 1 = Blank , 2 = Exitchar
.
          MOVE      ACODE,TV3UDF1           * Valid Code Entered
          MOVE      ACODE,TD3UDF1           * Code in the Display Variable
.
          GOTO      UDF35000
.
.------ no start code entered ------
.
UDF31000  MOVE      SP3,TV3UDF1             * Nothing Entered so Start of File
          MOVE      START,TD3UDF1           * Move Start to Display Variable
.
.------ display the first code details ------
.
UDF35000  DISPLAY   *PECOL:EVERT,*V2LON,TD3UDF1;
.
.------ keyin the second code ------
.
UDF35100  DISPLAY   *P35:EVERT,*EL,"to ";
.
          MOVE      SP3,TV3UDF2             * Clear To Variables
          MOVE      SP6,TD3UDF2
          MOVE      THIRTY8,ECOL
          MOVE      CODEG3,CODE             
          MOVE      SP3,CKYIDEF3
          MOVE      ZERO,CKYIMAND
.
          CALL      PATCODKY
          BRANCH    EXIT,UDF38000,UDF39000  * 1 = Blank , 2 = Exitchar
.
          MOVE      ACODE,TV3UDF2           * Valid Code Entered
          MOVE      ACODE,TD3UDF2           * Code in Display Variable
.
          MATCH     TV3UDF1,TV3UDF2         * Check From Date is Not Greater
          GOTO      UDF39500 IF NOT LESS    * Than the To Date
.
          DISPLAY   *P1:24,*EL,*B,"Invalid code range - Hit <":
                               *V2LON,"ENTER",*HOFF,"> to Continue ";
          KEYIN     *EOFF,ANS;
          DISPLAY   *P1:24,*EL;
.
          GOTO      UDF35100
.
.------ no second code entered ------
.
UDF38000  MOVE      ZEDS,TV3UDF2            * Set Value to "ZZZ" if <CR>
          MOVE      FINISH,TD3UDF2          * Display 'Finish'
.
          GOTO      UDF39500
.
.------ Exitchar was entered ------
.
UDF39000  MOVE      FALSE,FLAGUDF3          * Exitchar so Unset Range Flag
          UNPACK    SP6,TV3UDF1,TV3UDF2     * Clear Vorking Variables
          UNPACK    SP12,TD3UDF1,TD3UDF2
          DISPLAY   *P28:EVERT,*EL;
.
          GOTO      UDF39999
.
.------ display the second code details ------
.
UDF39500  DISPLAY   *PECOL:EVERT,*V2LON,TD3UDF2
.
UDF39999  RETURN
+
.********************************************************************** 
.*                            UDF40000                                *
.*                  Keyin the 4th User Defined Field range            *
.********************************************************************** 
UDF40000  MOVE      TRUE,FLAGUDF4           * Set Flag for this Range 
          MOVE      SP3,TV4UDF1             * Clear the From Variables
          MOVE      SP6,TD4UDF1
          MOVE      TWENTY8,ECOL
          MOVE      CODEG4,CODE             
          MOVE      SP3,CKYIDEF3
          MOVE      ZERO,CKYIMAND
.
          CALL      PATCODKY                * Keyin Codes File Field
          BRANCH    EXIT,UDF41000,UDF49000  * 1 = Blank , 2 = Exitchar
.
          MOVE      ACODE,TV4UDF1           * Valid Code Entered
          MOVE      ACODE,TD4UDF1           * Code in the Display Variable
.
          GOTO      UDF45000
.
.------ no first code entered ------
.
UDF41000  MOVE      SP3,TV4UDF1             * Nothing Entered so Start of File
          MOVE      START,TD4UDF1           * Move Start to Display Variable
.
.------ display the first code details ------
.
UDF45000  DISPLAY   *PECOL:EVERT,*V2LON,TD4UDF1;
.
.------ keyin the second code ------
.
UDF45100  DISPLAY   *P35:EVERT,*EL,"to ";
.
          MOVE      SP3,TV4UDF2             * Clear To Variables
          MOVE      SP6,TD4UDF2
          MOVE      THIRTY8,ECOL
          MOVE      CODEG4,CODE             
          MOVE      SP3,CKYIDEF3
          MOVE      ZERO,CKYIMAND
.
          CALL      PATCODKY
          BRANCH    EXIT,UDF48000,UDF49000  * 1 = Blank , 2 = Exitchar
.
          MOVE      ACODE,TV4UDF2           * Valid Code Entered
          MOVE      ACODE,TD4UDF2           * Code in Display Variable
.
          MATCH     TV4UDF1,TV4UDF2         * Check From Date is Not Greater
          GOTO      UDF49500 IF NOT LESS    * Than the To Date
.
          DISPLAY   *P1:24,*EL,*B,"Invalid code range - Hit <":
                               *V2LON,"ENTER",*HOFF,"> to Continue ";
          KEYIN     *EOFF,ANS;
          DISPLAY   *P1:24,*EL;
.
          GOTO      UDF45100
.
.------ no second code entered ------
.
UDF48000  MOVE      ZEDS,TV4UDF2            * Set Value to "ZZZ" if <CR>
          MOVE      FINISH,TD4UDF2          * Display 'Finish'
.
          GOTO      UDF49500
.
.------ Exitchar was entered ------
.
UDF49000  MOVE      FALSE,FLAGUDF4          * Exitchar so Unset Range Flag
          UNPACK    SP6,TV4UDF1,TV4UDF2     * Clear Vorking Variables
          UNPACK    SP12,TD4UDF1,TD4UDF2
          DISPLAY   *P28:EVERT,*EL;
.
          GOTO      UDF49999
.
.------ display the second code details ------
.
UDF49500  DISPLAY   *PECOL:EVERT,*V2LON,TD4UDF2
.
UDF49999  RETURN
+
.********************************************************************** 
.*                            UDF50000                                *
.*                  Keyin the 5th User Defined Field range            *
.********************************************************************** 
UDF50000  MOVE      TRUE,FLAGUDF5           * Set Flag for this Range 
          MOVE      SP3,TV5UDF1             * Clear the From Variables
          MOVE      SP6,TD5UDF1
          MOVE      TWENTY8,ECOL
          MOVE      CODEG5,CODE             
          MOVE      SP3,CKYIDEF3
          MOVE      ZERO,CKYIMAND
.
          CALL      PATCODKY                * Keyin Codes File Field
          BRANCH    EXIT,UDF51000,UDF59000  * 1 = Blank , 2 = Exitchar
.
          MOVE      ACODE,TV5UDF1           * Valid Code Entered
          MOVE      ACODE,TD5UDF1           * Code in the Display Variable
.
          GOTO      UDF55000
.
.------ no code entered ------
.
UDF51000  MOVE      SP3,TV5UDF1             * Nothing Entered so Start of File
          MOVE      START,TD5UDF1           * Move Start to Display Variable
.
.------ display the code details ------
.
UDF55000  DISPLAY   *PECOL:EVERT,*V2LON,TD5UDF1;
.
.------ keyin the second code ------
.
UDF55100  DISPLAY   *P35:EVERT,*EL,"to ";
.
          MOVE      SP3,TV5UDF2             * Clear To Variables
          MOVE      SP6,TD5UDF2
          MOVE      THIRTY8,ECOL
          MOVE      CODEG5,CODE             
          MOVE      SP3,CKYIDEF3
          MOVE      ZERO,CKYIMAND
.
          CALL      PATCODKY
          BRANCH    EXIT,UDF58000,UDF59000  * 1 = Blank , 2 = Exitchar
.
          MOVE      ACODE,TV5UDF2           * Valid Code Entered
          MOVE      ACODE,TD5UDF2           * Code in Display Variable
.
          MATCH     TV5UDF1,TV5UDF2         * Check From Date is Not Greater
          GOTO      UDF59500 IF NOT LESS    * Than the To Date
.
          DISPLAY   *P1:24,*EL,*B,"Invalid code range - Hit <":
                               *V2LON,"ENTER",*HOFF,"> to Continue ";
          KEYIN     *EOFF,ANS;
          DISPLAY   *P1:24,*EL;
.
          GOTO      UDF55100
.
.------ no second code entered ------
.
UDF58000  MOVE      ZEDS,TV5UDF2            * Set Value to "ZZZ" if <CR>
          MOVE      FINISH,TD5UDF2          * Display 'Finish'
.
          GOTO      UDF59500
.
.------ Exitchar was entered ------
.
UDF59000  MOVE      FALSE,FLAGUDF5          * Exitchar so Unset Range Flag
          UNPACK    SP6,TV5UDF1,TV5UDF2     * Clear Vorking Variables
          UNPACK    SP12,TD5UDF1,TD5UDF2
          DISPLAY   *P28:EVERT,*EL;
.
          GOTO      UDF59999
.
.------ display the second code details ------
.
UDF59500  DISPLAY   *PECOL:EVERT,*V2LON,TD5UDF2  
.
UDF59999  RETURN
+
.********************************************************************** 
.*                            UDF60000                                *
.*                  Keyin the 6th User Defined Field range            *
.********************************************************************** 
UDF60000  MOVE      TRUE,FLAGUDF6           * Set Flag for this Range 
          MOVE      SP3,TV6UDF1             * Clear the From Variables
          MOVE      SP6,TD6UDF1
          MOVE      TWENTY8,ECOL
          MOVE      CODEG6,CODE             
          MOVE      SP3,CKYIDEF3
          MOVE      ZERO,CKYIMAND
.
          CALL      PATCODKY                * Keyin Codes File Field
          BRANCH    EXIT,UDF61000,UDF69000  * 1 = Blank , 2 = Exitchar
.
          MOVE      ACODE,TV6UDF1           * Valid Code Entered
          MOVE      ACODE,TD6UDF1           * Code in the Display Variable
.
          GOTO      UDF65000
.
.------ no first code entered ------
.
UDF61000  MOVE      SP3,TV6UDF1             * Nothing Entered so Start of File
          MOVE      START,TD6UDF1           * Move Start to Display Variable
.
.------ display the first code details ------
.
UDF65000  DISPLAY   *PECOL:EVERT,*V2LON,TD6UDF1;
.
.------ keyin the second code ------
.
UDF65100  DISPLAY   *P35:EVERT,*EL,"to ";
.
          MOVE      SP3,TV6UDF2              * Clear To Variables
          MOVE      SP6,TD6UDF2
          MOVE      THIRTY8,ECOL
          MOVE      CODEG6,CODE              * Parameters for PATCODKY 
          MOVE      SP3,CKYIDEF3
          MOVE      ZERO,CKYIMAND
.
          CALL      PATCODKY
          BRANCH    EXIT,UDF68000,UDF69000  * 1 = Blank , 2 = Exitchar
.
          MOVE      ACODE,TV6UDF2           * Valid Code Entered
          MOVE      ACODE,TD6UDF2           * Code in Display Variable
.
          MATCH     TV6UDF1,TV6UDF2         * Check From Date is Not Greater
          GOTO      UDF69500 IF NOT LESS    * Than the To Date
.
          DISPLAY   *P1:24,*EL,*B,"Invalid code range - Hit <":
                               *V2LON,"ENTER",*HOFF,"> to Continue ";
          KEYIN     *EOFF,ANS;
          DISPLAY   *P1:24,*EL;
.
          GOTO      UDF65100
.
.------ no second code entered ------
.
UDF68000  MOVE      ZEDS,TV6UDF2            * Set Value to "ZZZ" if <CR>
          MOVE      FINISH,TD6UDF2          * Display 'Finish'
.
          GOTO      UDF69500
.
.------ Exitchar was entered ------
.
UDF69000  MOVE      FALSE,FLAGUDF6          * Exitchar so Unset Range Flag
          UNPACK    SP6,TV6UDF1,TV6UDF2     * Clear Vorking Variables
          UNPACK    SP12,TD6UDF1,TD6UDF2
          DISPLAY   *P28:EVERT,*EL;
.
          GOTO      UDF69999
.
.------ display the second code ------
.
UDF69500  DISPLAY   *PECOL:EVERT,*V2LON,TD6UDF2
.
UDF69999  RETURN
+
.********************************************************************** 
.*                            UDF70000                                *
.*                  Keyin the 7th User Defined Field range            *
.********************************************************************** 
UDF70000  MOVE      TRUE,FLAGUDF7           * Set Flag for this Range 
          MOVE      SP3,TV7UDF1             * Clear the From Variables
          MOVE      SP6,TD7UDF1
          MOVE      TWENTY8,ECOL
          MOVE      CODEG7,CODE             * Parameters for PATCODKY
          MOVE      SP3,CKYIDEF3
          MOVE      ZERO,CKYIMAND
.
          CALL      PATCODKY                * Keyin Codes File Field
          BRANCH    EXIT,UDF71000,UDF79000  * 1 = Blank , 2 = Exitchar
.
          MOVE      ACODE,TV7UDF1           * Valid Code Entered
          MOVE      ACODE,TD7UDF1           * Code in the Display Variable
.
          GOTO      UDF75000
.
.------ no first code entered ------
.
UDF71000  MOVE      SP3,TV7UDF1             * Nothing Entered so Start of File
          MOVE      START,TD7UDF1           * Move Start to Display Variable
.
.------ display the first code details ------
.
UDF75000  DISPLAY   *PECOL:EVERT,*V2LON,TD7UDF1;
.
.------ keyin the second code ------
.
UDF75100  DISPLAY   *P35:EVERT,*EL,"to ";
.
          MOVE      SP3,TV7UDF2             * Clear To Variables
          MOVE      SP6,TD7UDF2
          MOVE      THIRTY8,ECOL
          MOVE      CODEG6,CODE             
          MOVE      SP3,CKYIDEF3
          MOVE      ZERO,CKYIMAND
.
          CALL      PATCODKY
          BRANCH    EXIT,UDF78000,UDF79000  * 1 = Blank , 2 = Exitchar
.
          MOVE      ACODE,TV7UDF2           * Valid Code Entered
          MOVE      ACODE,TD7UDF2           * Code in Display Variable
.
          MATCH     TV7UDF1,TV7UDF2         * Check From Date is Not Greater
          GOTO      UDF79500 IF NOT LESS    * Than the To Date
.
          DISPLAY   *P1:24,*EL,*B,"Invalid code range - Hit <":
                               *V2LON,"ENTER",*HOFF,"> to Continue ";
          KEYIN     *EOFF,ANS;
          DISPLAY   *P1:24,*EL;
.
          GOTO      UDF75100
.
.------ no second code entered ------
.
UDF78000  MOVE      ZEDS,TV7UDF2            * Set Value to "ZZZ" if <CR>
          MOVE      FINISH,TD7UDF2          * Display 'Finish'
.
          GOTO      UDF79500
.
.------ Exitchar was entered ------
.
UDF79000  MOVE      FALSE,FLAGUDF7          * Exitchar so Unset Range Flag
          UNPACK    SP6,TV7UDF1,TV7UDF2     * Clear Vorking Variables
          UNPACK    SP12,TD7UDF1,TD7UDF2
          DISPLAY   *P28:EVERT,*EL;
.
          GOTO      UDF79999
.
.------ display the second code ------
.
UDF79500  DISPLAY   *PECOL:EVERT,*V2LON,TD7UDF2
.
UDF79999  RETURN
+
.********************************************************************** 
.*                            UDF80000                                *
.*                  Keyin the 8th User Defined Field range            *
.********************************************************************** 
UDF80000  MOVE      TRUE,FLAGUDF8           * Set Flag for this Range 
          MOVE      SP3,TV8UDF1             * Clear the From Variables
          MOVE      SP6,TD8UDF1
          MOVE      TWENTY8,ECOL
          MOVE      CODEG8,CODE             
          MOVE      SP3,CKYIDEF3
          MOVE      ZERO,CKYIMAND
.
          CALL      PATCODKY                * Keyin Codes File Field
          BRANCH    EXIT,UDF81000,UDF89000  * 1 = Blank , 2 = Exitchar
.
          MOVE      ACODE,TV8UDF1           * Valid Code Entered
          MOVE      ACODE,TD8UDF1           * Code in the Display Variable
.
          GOTO      UDF85000
.
.------ no first code entered ------
.
UDF81000  MOVE      SP3,TV8UDF1             * Nothing Entered so Start of File
          MOVE      START,TD8UDF1           * Move Start to Display Variable
.
.------ display the first code ------
.
UDF85000  DISPLAY   *PECOL:EVERT,*V2LON,TD8UDF1;
.
.------ keyin the second code ------
.
UDF85100  DISPLAY   *P35:EVERT,*EL,"to ";
.
          MOVE      SP3,TV8UDF2             * Clear To Variables
          MOVE      SP6,TD8UDF2
          MOVE      THIRTY8,ECOL
          MOVE      CODEG8,CODE             
          MOVE      SP3,CKYIDEF3
          MOVE      ZERO,CKYIMAND
.
          CALL      PATCODKY
          BRANCH    EXIT,UDF88000,UDF89000  * 1 = Blank , 2 = Exitchar
.
          MOVE      ACODE,TV8UDF2           * Valid Code Entered
          MOVE      ACODE,TD8UDF2           * Code in Display Variable
.
          MATCH     TV8UDF1,TV8UDF2         * Check From Date is Not Greater
          GOTO      UDF89500 IF NOT LESS    * Than the To Date
.
          DISPLAY   *P1:24,*EL,*B,"Invalid code range - Hit <":
                               *V2LON,"ENTER",*HOFF,"> to Continue ";
          KEYIN     *EOFF,ANS;
          DISPLAY   *P1:24,*EL;
.
          GOTO      UDF85100
.
.------ no second code entered ------
.
UDF88000  MOVE      ZEDS,TV8UDF2            * Set Value to "ZZZ" if <CR>
          MOVE      FINISH,TD8UDF2          * Display 'Finish'
.
          GOTO      UDF89500
.
UDF89000  MOVE      FALSE,FLAGUDF8          * Exitchar so Unset Range Flag
          UNPACK    SP6,TV8UDF1,TV8UDF2     * Clear Vorking Variables
          UNPACK    SP12,TD8UDF1,TD8UDF2
          DISPLAY   *P28:EVERT,*EL;
.
          GOTO      UDF89999
.
UDF89500  DISPLAY   *PECOL:EVERT,*V2LON,TD8UDF2  
.
UDF89999  RETURN
+
.**********************************************************************
.*                              CREA0000                              *
.*                   Create the Indexed Temp File                     *
.**********************************************************************
CREA0000  DISPLAY   *P1:24,*EL,*V2LON,*BLINKON,"Creating Indexed Temp File":
                           *HOFF," - Please Wait";
          CLEAR     FNAMER
          APPEND    "pritm1",FNAMER
          APPEND    PORT,FNAMER
          RESET     FNAMER
          REP       " 0",FNAMER
.
          CALL      KILL0000                       * kill existing temp file
.
.------ Build new indexed temp file ------
.
          CLEAR     CMDLINE
          APPEND    "isbuild ",CMDLINE
          APPEND    FNAMER,CMDLINE
          APPEND    " 38 u1-8,9-10,11-18",CMDLINE
          APPEND    SP30,CMDLINE
          RESET     CMDLINE
.
          EXECUTE   CMDLINE,TASKID
          OPEN      PRITM1XX,FNAMER
.
CREA9999  RETURN
+
.**********************************************************************
.*                              KILL0000                              *
.*                  Kill the Tempfile if it Already Exists            *
.**********************************************************************
KILL0000  CLEAR     CMDLINE
          CLOSE     PRITM1XX
          APPEND    "iserase ",CMDLINE
          APPEND    FNAMER,CMDLINE
          RESET     CMDLINE
.
          EXECUTE   CMDLINE,TASKID
.
KILL9999  RETURN
+
.********************************************************************** 
.*                            EXTR0000                                *
.*                   Extract Patients from Files                      *
.********************************************************************** 
EXTR0000  DISPLAY   *P1:24,*EL,"Scanning Debtor No : ":
                    *P32:24,"Found : ":
                    *P52:24,"Number of Records : ";
.
          MOVE      FALSE,EXIT
          MOVE      ZERO,RECCOUNT
          MOVE      SP3,PRHDCLAM
          MOVE      FLAGURNO,PRHDSCAN
          LOAD      PRHDCLAM,FLAGCLAM,TVCLAM1
.
          PACK      KEY27,SNUMB,PRHDSCAN,PRHDCLAM,SP8
          CALL      RSPRHD1                 * position on the holding header 
.                                             file
.------ read through the holding header file ------
.
EXTR1000  CALL      RKPRHD1
          BRANCH    OVRCD,EXTR9000
.
          DISPLAY   *P22:24,PRHDDEBT;
.
          BRANCH    FLAGALL,EXTR2000        * see if we are processing all
.                                             patients
          BRANCH    FLAGDEBT,EXTR1100       * skip if we are processing only
.                                             debtor numbers
          COMPARE   ZERO,PRHDSCAN           * see if we have a debtor number
          GOTO      EXTR1000 IF EQUAL
.
          MATCH     PRHDDEBT,ENUMB          * see if U/R number is in range
          GOTO      EXTR9000 IF LESS
.
          GOTO      EXTR2000
.
.------ we are processing debtor numbers so skip if we have a U/R ------
.
EXTR1100  BRANCH    PRHDSCAN,EXTR1000
.
          MATCH     PRHDDEBT,ENUMB          * see if debtor number is in range
          GOTO      EXTR9000 IF LESS
.
.------ skip if we have no claim code range ------
.
EXTR2000  COMPARE   ZERO,FLAGCLAM
          GOTO      EXTR3000 IF EQUAL
.
          MATCH     TVCLAM1,PRHDCLAM        * see if claim code is in range
          GOTO      EXTR1000 IF LESS
.
          MATCH     PRHDCLAM,TVCLAM2        * see if claim code is in range
          GOTO      EXTR1000 IF LESS
.
.------ skip if we have no surname range ------
.
EXTR3000  COMPARE   ZERO,FLAGSURN
          GOTO      EXTR4000 IF EQUAL
.
          BRANCH    PRHDSCAN,EXTR3500       * skip if we have a U/R number
.
...          MOVE      PRHDDEBT,KEY8
...          CALL      RDPRDB1                 * read the debtor file
...          BRANCH    OVRCD,EXTR1000
.
...          MATCH     TVSURN1,PRDBSNAM        * see if surname is in range
...          GOTO      EXTR1000 IF LESS
.
...          MATCH     PRDBSNAM,TVSURN2        * see if surname is in range
...          GOTO      EXTR1000 IF LESS
.
          GOTO      EXTR4000
.
.------ we have a U/R number ------
.
EXTR3500  MOVE      PRHDDEBT,PURNO
          MOVE      PURNO,KEY8
          CALL      RDMAST1                 * read the patient master file
          BRANCH    OVRCD,EXTR1000
.
          MATCH     TVSURN1,PSNAME          * see if surname is in range
          GOTO      EXTR1000 IF LESS
.
          MATCH     PSNAME,TVSURN2          * see if surname is in range
          GOTO      EXTR4000 IF EQUAL
          GOTO      EXTR1000 IF LESS
.
.------ position on the holding referral file ------
.
EXTR4000  PACK      KEY27,PRHDUNIQ,SP20
          CALL      RSPRHR1
.
.------ read through the holding referral file -----
.
EXTR4100  CALL      RKPRHR1
          BRANCH    OVRCD,EXTR1000
.
          COMPARE   PRHDUNIQ,PRHRUNIQ       * see if we have the same unique
          GOTO      EXTR1000 IF NOT EQUAL     identifier
.
          COMPARE   ZERO,FLAGVIST           * skip if we have no visit date
          GOTO      EXTR5000 IF EQUAL         range
.
          PACK      KEY62,PRHRUNIQ,PRHRPRAC,PRHRDOCT,PRHRPIND,SP30,SP30
          CALL      RSPRHT1                 * position on the transaction file
          CALL      RKPRHT1
          BRANCH    OVRCD,EXTR4500
.
          COMPARE   PRHRUNIQ,PRHTUNIQ       * compare unique identifiers
          GOTO      EXTR4500 IF NOT EQUAL
.
          MATCH     PRHRPRAC,PRHTPRAC       * match practices
          GOTO      EXTR4500 IF NOT EQUAL
.
          MATCH     PRHRDOCT,PRHTDOCT       * match service doctors
          GOTO      EXTR4500 IF NOT EQUAL
.
          MATCH     PRHRPIND,PRHTPIND       * match patient indicators
          GOTO      EXTR4500 IF NOT EQUAL
.
          GOTO      EXTR4250
.
.------ get the next transaction record ------
.
EXTR4200  CALL      RKPRHT1
          BRANCH    OVRCD,EXTR4100
.
          COMPARE   PRHRUNIQ,PRHTUNIQ       * compare unique identifiers
          GOTO      EXTR4100 IF NOT EQUAL
.
          MATCH     PRHRPRAC,PRHTPRAC       * match medical practices
          GOTO      EXTR4100 IF NOT EQUAL
.
          MATCH     PRHRDOCT,PRHTDOCT       * match service doctors
          GOTO      EXTR4100 IF NOT EQUAL
.
          MATCH     PRHRPIND,PRHTPIND       * match patient indicators
          GOTO      EXTR4100 IF NOT EQUAL
.
.------ see if the visit date is in range ------
.
EXTR4250  MATCH     TVVIST1,PRHTDATE
          GOTO      EXTR4200 IF LESS
.
          MATCH     PRHTDATE,TVVIST2        * see if the visit date is in 
          GOTO      EXTR4200 IF LESS          range
.
          GOTO      EXTR5000
.
.------ there are no transactions so try the debtors transaction file ------
.
EXTR4500  PACK      KEY22,PRHRUNIQ,SP20
          CALL      RSPRDT1                 * position on the debtors 
.                                             transaction file
.------ read through the debtors transaction file ------
.
EXTR4600  CALL      RKPRDT1
          BRANCH    OVRCD,EXTR4100
.
          COMPARE   PRHRUNIQ,PRDTUNIQ       * compare the unique identifiers
          GOTO      EXTR4100 IF NOT EQUAL
.
          COMPARE   ONE,PRDTRTYP            * item transaction ?
          GOTO      EXTR4600 IF NOT EQUAL   * no
.
          MATCH     TVVIST1,PRDTSDAT        * match visit dates
          GOTO      EXTR4600 IF LESS
.
          MATCH     PRDTSDAT,TVVIST2        * match visit dates
          GOTO      EXTR4600 IF LESS
.
.------ skip if we have no practice range ------
.
EXTR5000  COMPARE   ZERO,FLAGPRAC
          GOTO      EXTR6000 IF EQUAL
.
          MATCH     SPRAC,PRHRPRAC          * see if practices are in range
          GOTO      EXTR4100 IF LESS
.
          MATCH     PRHRPRAC,EPRAC          * see if practices are in range
          GOTO      EXTR4100 IF LESS
.
.------ skip if we have no service doctor range ------
.
EXTR6000  COMPARE   ZERO,FLAGSDOC
          GOTO      EXTR7000 IF EQUAL
.
          MATCH     SDOCT,PRHRDOCT          * see if service doctors are in 
          GOTO      EXTR4100 IF LESS          range
.
          MATCH     PRHRDOCT,EDOCT          * see if service doctors are in 
          GOTO      EXTR4100 IF LESS          range
.
.------ skip if we have no first user defined field range ------
.
EXTR7000  COMPARE   ZERO,FLAGUDF1
          GOTO      EXTR7200 IF EQUAL
.
          MATCH     TV1UDF1,PRHRUDF1        * see if user defined field is in
          GOTO      EXTR4100 IF LESS          range
.
          MATCH     PRHRUDF1,TV1UDF2        * see if user defined field is in
          GOTO      EXTR4100 IF LESS          range
.
.------ skip if we have no second user defined field range ------
.
EXTR7200  COMPARE   ZERO,FLAGUDF2
          GOTO      EXTR7400 IF EQUAL
.
          MATCH     TV2UDF1,PRHRUDF2        * see if user defined field is in
          GOTO      EXTR4100 IF LESS          range
.
          MATCH     PRHRUDF2,TV2UDF2        * see if user defined field is in
          GOTO      EXTR4100 IF LESS          range
.
.------ skip if we have no three user defined field range ------
.
EXTR7400  COMPARE   ZERO,FLAGUDF3
          GOTO      EXTR7600 IF EQUAL
.
          MATCH     TV3UDF1,PRHRUDF3        * see if user defined field is in
          GOTO      EXTR4100 IF LESS          range
.
          MATCH     PRHRUDF3,TV3UDF2        * see if user defined field is in
          GOTO      EXTR4100 IF LESS          range
.
.------ skip if we have no fourth user defined field range ------
.
EXTR7600  COMPARE   ZERO,FLAGUDF4
          GOTO      EXTR8600 IF EQUAL
.
          MATCH     TV4UDF1,PRHRUDF4        * see if user defined field is in
          GOTO      EXTR4100 IF LESS          range
.
          MATCH     PRHRUDF4,TV4UDF2        * see if user defined field is in
          GOTO      EXTR4100 IF LESS          range
.
          GOTO      EXTR8600
.
.------ skip if we have no fifth user defined field range ------
.
EXTR7800  COMPARE   ZERO,FLAGUDF5
          GOTO      EXTR8000 IF EQUAL
.
...          MOVE      PRHDDEBT,KEY8
...          CALL      RDPRDB1                 * read the debtor file
...          BRANCH    OVRCD,EXTR1000
.
...          MATCH     TV5UDF1,PRDBUDF1        * see if user defined field is in
...          GOTO      EXTR1000 IF LESS          range
.
...          MATCH     PRDBUDF1,TV5UDF2        * see if user defined field is in
...          GOTO      EXTR1000 IF LESS          range
.
.------ skip if we have no sixth user defined field range ------
.
EXTR8000  COMPARE   ZERO,FLAGUDF6
          GOTO      EXTR8200 IF EQUAL
.
...          MOVE      PRHDDEBT,KEY8
...          CALL      RDPRDB1                 * read the debtor file
...          BRANCH    OVRCD,EXTR1000
.
...          MATCH     TV6UDF1,PRDBUDF2        * see if user defined field is in
...          GOTO      EXTR1000 IF LESS          range
.
...          MATCH     PRDBUDF2,TV6UDF2        * see if user defined field is in
...          GOTO      EXTR1000 IF LESS          range
.
.------ skip if we have no seventh user defined field range ------
.
EXTR8200  COMPARE   ZERO,FLAGUDF7
          GOTO      EXTR8400 IF EQUAL
.
...          MOVE      PRHDDEBT,KEY8
...          CALL      RDPRDB1                 * read the debtor file
...          BRANCH    OVRCD,EXTR1000
.
...          MATCH     TV7UDF1,PRDBUDF3        * see if user defined field is in
...          GOTO      EXTR1000 IF LESS          range
.
...          MATCH     PRDBUDF3,TV7UDF2        * see if user defined field is in
...          GOTO      EXTR1000 IF LESS          range
.
.------ skip if we have no eighth user defined field range ------
.
EXTR8400  COMPARE   ZERO,FLAGUDF8
          GOTO      EXTR8600 IF EQUAL
.
...          MOVE      PRHDDEBT,KEY8
...          CALL      RDPRDB1                 * read the debtor file
...          BRANCH    OVRCD,EXTR1000
.
...          MATCH     TV8UDF1,PRDBUDF4        * see if user defined field is in
...          GOTO      EXTR1000 IF LESS          range
.
...          MATCH     PRDBUDF4,TV8UDF2        * see if user defined field is in
...          GOTO      EXTR1000 IF LESS          range
.
.------ read the temp file ------
.
EXTR8600  MATCH     "IBARSH",PGM
          GOTO      EXTR8700 IF EQUAL 
.
          PACK      KEY18,PRHDDEBT,PRHDSCAN,PRHDUNIQ
          CALL      RDTMPR1
          COMPARE   ZERO,OVRCD
          GOTO      EXTR1000 IF EQUAL
.
          MOVE      PRHRPRAC,TMPPRAC
          MOVE      PRHRDOCT,TMPSDOC
          MOVE      PRHRPIND,TMPPIND
.
          CALL      WRTMPR1                 * write to the temp file
          GOTO      EXTR8800
.
EXTR8700  PACK      KEY22,SELECTID,PRHDDEBT,PRHDSCAN,PRHDUNIQ
          CALL      RDPRGSL1
          COMPARE   ZERO,OVRCD
          GOTO      EXTR1000 IF EQUAL
.
          MOVE      PRGLSEID,PRGSSEID
          MOVE      PRHDDEBT,PRGSDEBT
          MOVE      PRHDSCAN,PRGSSCAN
          MOVE      PRHDUNIQ,PRGSUNIQ
          MOVE      PRHRPRAC,PRGSPRAC
          MOVE      PRHRDOCT,PRGSSDOC
          MOVE      PRHRPIND,PRGSPIND
          PACK      PRGSSTAT,SP2
.
          CALL      WRPRGSL1                * write to the temp file
.
EXTR8800  ADD       ONE,RECCOUNT
          DISPLAY   *P40:24,*V2LON,PRHDDEBT:
                    *P73:24,RECCOUNT;
.
          GOTO      EXTR1000

.
.------ all records have been processed so see if any were actually ------
.------ written to the temp file ------
.
EXTR9000  COMPARE   ZERO,RECCOUNT
          GOTO      EXTR9999 IF NOT EQUAL
.
          DISPLAY   *P1:24,*EL,*B,"No patients found for these criteria":
                           " - Hit <",*V2LON,"ENTER",*HOFF,"> to continue";
          KEYIN     ANS;
          DISPLAY   *P1:24,*EL;
          MOVE      TRUE,EXIT
.
EXTR9999  RETURN
+
.********************************************************************** 
.*                            PATS0000                                *
.*                  Process the Extracted Patients                    *
.*                                                                    *
.*       Called by ML0000                                             *
.*                           Exit = 0  Send the Letters               *
.*                                  1  Exit to Option Screen          *
.*                                  2  No Patients, Retain Selection  *
.*                                                                    *
.********************************************************************** 
PATS0000  DISPLAY   *P1:3,*EF,*V2LON,*ULON:
                    *P5:4,"Debt No.":
                    *P14:4,"Patient's Name ":
                    *P30:4,"Claim Code     ":
                    *P46:4,"Med. Practice  ":
                    *P62:4,"Service Doctor    ";
.
          MOVE      ONE,RECNUMB             * Reset the Counters
          MOVE      FIVE,SCRNPOS
          MOVE      ONE,SCRNNUMB
.
          CALL      CLKY0000                * Clear all Key Variables
.
          MOVE      SP20,KEY18    
          CALL      RSTMPR1                 * position on the temp file
.
.------ read through the temp file ------
.
PATS1000  CALL      RKTMPR1                
          BRANCH    OVRCD,PATS2000
.
          COMPARE   TEN9,RECNUMB            * see if the screen is full
          GOTO      PATS1500 IF NOT LESS
.
.------ display a line of data ------
.
PATS1200  CALL      DATA0000                
          BRANCH    EXIT,PATS1000           * Data File Record Missing
.
          ADD       ONE,RECNUMB
          ADD       ONE,SCRNPOS
.
          GOTO      PATS1000
.
.------ screen is full so select an option ------
.
PATS1500  CALL      B2SL0000
          BRANCH    EXIT,PATS9000,PATS9500,PATS5000,PATS7000
.                          Exit     Send     Prev     Next
.
          CALL      DELT0000                * Delete a Record from Temp File
          BRANCH    EXIT,PATS9000,PATS8000
.                          Eof       No
          GOTO      PATS1000
.
.------ we are at the end of the temp file so see if we have the first ------
.------ record ------
.
PATS2000  COMPARE   ONE,RECNUMB
          GOTO      PATS3000 IF NOT EQUAL
.
          COMPARE   ONE,SCRNNUMB            * If 1st Screen & No records
          GOTO      PATS2500 IF EQUAL       * Display an Error Message
.
          GOTO      PATS5000                * Get Previous Screen
.
.------ no patients on the temp file ------
.
PATS2500  DISPLAY   *P1:24,*EL,*B,"No Patients Found - Hit <":
                               *V2LON,"ENTER",*HOFF,"> to Continue ";
          KEYIN     *EOFF,ANS;
          DISPLAY   *P1:24,*EL;
.
          GOTO      PATS9000                * Exit
.
.------ we are at the end of the temp file so select an option ------
.
PATS3000  CALL      B1SL0000                * Selection
          BRANCH    EXIT,PATS9000,PATS9500,PATS5000
.                          Exit     Send     Prev
.
          CALL      DELT0000                * Delete a Record from Temp File
          BRANCH    EXIT,PATS9000,PATS8000
.                          Eof       No
          GOTO      PATS1000
.
.------ display the previous screen ------
.
PATS5000  CALL      PREV0000                * Previous Screen
.
          CALL      CLKY0000                * clear the key variables
.
          GOTO      PATS1200
.
.------ display the next screen ------
.
PATS7000  CALL      NEXT0000                * Next Screen
.
          GOTO      PATS1200
.
.------ not O.K. to delete so return to selecting an option ------
.
PATS8000  BRANCH    SELFLAG,PATS3000,PATS1500
.
.------ we want to Exit so restore the screen ------
.
PATS9000  CALL      PUTSCR00
.
          MOVE      TRUE,EXIT
.
          GOTO      PATS9999
.
.------ It is O.K. to send the letters ------
.
PATS9500  MOVE      FALSE,EXIT
.
PATS9999  RETURN
+
.********************************************************************** 
.*                            CLKY0000                                *
.*                    Clear all Temp Key Variables                    *
.********************************************************************** 
CLKY0000  MOVE      SP20,KEYST1
          MOVE      SP20,KEYST2
          MOVE      SP20,KEYST3
          MOVE      SP20,KEYST4
          MOVE      SP20,KEYST5
          MOVE      SP20,KEYST6
          MOVE      SP20,KEYST7
          MOVE      SP20,KEYST8
          MOVE      SP20,KEYST9
          MOVE      SP20,KEYST10
          MOVE      SP20,KEYST11
          MOVE      SP20,KEYST12
          MOVE      SP20,KEYST13
          MOVE      SP20,KEYST14
          MOVE      SP20,KEYST15
          MOVE      SP20,KEYST16
          MOVE      SP20,KEYST17
          MOVE      SP20,KEYST18
.
CLKY9999  RETURN
+
.********************************************************************** 
.*                            DATA0000                                *
.*                    Display a Screen of Data                        *
.********************************************************************** 
DATA0000  BRANCH    TMPSCAN,DATA0100        * skip if we have a U/R number
.
...          MOVE      TMPDEBT,KEY8
...          CALL      RDPRDB1                 * read the debtor file
...          BRANCH    OVRCD,DATA9000
.
...          MOVE      PRDBSNAM,PACSNAME
...          MOVE      PRDBGNAM,PACGNAME
...          MOVE      PRDBTITL,PACTITLE
...          MOVE      "2",PACFRMT
.
...          CALL      PACNAME                 * Format Patient's Name
.
          MOVE      "Unknown Debtor Number",PACFNAME
          PACK      PACFNAME,PACFNAME,SP70
          MOVE      PACFNAME,PATNAME
.
          GOTO      DATA0200
.
.------ we have a U/R number ------
.
DATA0100  MOVE      TMPDEBT,PURNO
          MOVE      PURNO,KEY8
          CALL      RDMAST1                 * read the patient master file
          BRANCH    OVRCD,DATA9000
.
          MOVE      PSNAME,PACSNAME
          MOVE      PGNAME,PACGNAME
          MOVE      PTITL,PACTITLE
          MOVE      "2",PACFRMT
.
          CALL      PACNAME                 * Format Patient's Name
.
          MOVE      PACFNAME,PATNAME
.
.------ read the header file ------
.
DATA0200  MOVE      TMPUNIQ,KEY8
          CALL      RDPRHD2
          BRANCH    OVRCD,DATA9000
.
          PACK      KEY27,TMPUNIQ,TMPPRAC,TMPSDOC,TMPPIND
          CALL      RDPRHR1                 * read the referral file
          BRANCH    OVRCD,DATA9000
.
          MOVE      "Unknown Desc",TDESC
          PACK      KEY5,CODECL,PRHDCLAM
          CALL      RDCODE1                 * read the patient codes file
          MOVE      TDESC,DESCCLAM
.
          MOVE      "Unknown Prac.",PRPRDESC
          MOVE      TMPPRAC,KEY6
          CALL      RDPRPR1                 * read the practice file
          MOVE      PRPRDESC,DESCPRAC
.
          MOVE      "Unknown Doct.",DOCNAME
          MOVE      TMPSDOC,KEY6
          PACK      KEY10,TMPSDOC,SP10
          CALL      RDPMHCP1                * read the doctor file
          BRANCH    OVRCD,DATA1000
.
          MOVE      PMHCSNAM,PACSNAME
          MOVE      PMHCGNAM,PACGNAME
          MOVE      PMHCTITL,PACTITLE
          MOVE      "1",PACFRMT
.
          CALL      PACNAME                 * Format Patient's Name
.
          MOVE      PACFNAME,DOCNAME
.
.------ store the key and display the current record ------
.
DATA1000  PACK      KEY18,TMPDEBT,TMPSCAN,TMPUNIQ
          STORE     KEY18,RECNUMB,KEYST1,KEYST2,KEYST3:
                                  KEYST4,KEYST5,KEYST6:
                                  KEYST7,KEYST8,KEYST9:
                                  KEYST10,KEYST11,KEYST12:
                                  KEYST13,KEYST14,KEYST15:
                                  KEYST16,KEYST17,KEYST18
.
          DISPLAY   *P1:SCRNPOS,*V2LON,RECNUMB,*HOFF:
                    *P3:SCRNPOS,DOT:
                    *P5:SCRNPOS,TMPDEBT:
                    *P14:SCRNPOS,PATNAME:
                    *P30:SCRNPOS,DESCCLAM:
                    *P46:SCRNPOS,DESCPRAC:
                    *P62:SCRNPOS,DOCNAME;
.
          MOVE      FALSE,EXIT
.
          GOTO      DATA9999
.
.------ a record is missing for this patient ------
.
DATA9000  MOVE      TRUE,EXIT
.
DATA9999  RETURN
+
.********************************************************************** 
.*                            PREV0000                                *
.*                       Get Previous Screen                          *
.********************************************************************** 
PREV0000  DISPLAY   *P1:5,*EF;
          MOVE      ZERO,FORM2
.
          MOVE      KEYST1,KEY18
          CALL      RSTMPR1                 * position on the temp file
.
.------ get the previous record ------
.
PREV1000  CALL      RPTMPR1
          BRANCH    OVRCD,PREV9999
.
          ADD       ONE,FORM2
.
          COMPARE   TEN8,FORM2              * see if we are at the first record
          GOTO      PREV1000 IF LESS          of the previous screen
.
          MOVE      ONE,RECNUMB
          MOVE      FIVE,SCRNPOS
          SUB       ONE,SCRNNUMB
          PACK      KEYST1,TMPDEBT,TMPSCAN,TMPUNIQ
.
PREV9999  RETURN
+
.********************************************************************** 
.*                            NEXT0000                                *
.*                        Get Next Screen                             *
.********************************************************************** 
NEXT0000  DISPLAY   *P1:5,*EF;
.
          CALL      CLKY0000                * clear the key variables
.
          MOVE      ONE,RECNUMB
          MOVE      FIVE,SCRNPOS
          ADD       ONE,SCRNNUMB
.
NEXT9999  RETURN
+
.********************************************************************** 
.*                            B1SL0000                                *
.*                    Batch Screen Select Routine                     *
.*                   Used When End of File Reached                    *
.*                                                                    *
.*                                                                    *
.*  Exit  0 = Valid Record to Delete                                  *
.*        1 = Exit                                                    *
.*        2 = Send the Letter                                         *
.*        3 = Previous Screen                                         *
.*                                                                    *
.********************************************************************** 
B1SL0000  MOVE      ONE,SELFLAG
.
          BRANCH    SCRNNUMB,B1SL1000       * skip if the first screen
.
          DISPLAY   *P1:24,"Select Item to Delete, ":
                           "(",*V2LON,ANSE,*HOFF,")xit, ":
                           "(",*V2LON,ANSS,*HOFF,")end Letter, ":
                           "(",*V2LON,ANSP,*HOFF,")revious ? "
.
          MOVE      SIXTY,CCOL
.
          GOTO      B1SL2000
.
.------ we are on the first screen ------
.
B1SL1000  DISPLAY   *P1:24,"Select Item to Delete, ":
                           "(",*V2LON,ANSE,*HOFF,")xit, ":
                           "(",*V2LON,ANSS,*HOFF,")end Letter ? ";
.
          MOVE      FORTY8,CCOL
.
.------ select an option ------
.
B1SL2000  KEYIN     *PCCOL:24,*EL,*DV,UNDLN2,*PCCOL:24,*V2LON,*JR,DIM2;
.
          TYPE      DIM2                    * skip if not a number
          GOTO      B1SL3000 IF NOT EQUAL
.
          MOVE      DIM2,FORM2
.
          COMPARE   ONE,FORM2               * make sure a valid record has
          GOTO      B1SL9000 IF LESS          been chosen
.
          COMPARE   RECNUMB,FORM2           * make sure a valid record has
          GOTO      B1SL9000 IF NOT LESS      been chosen
.
          MOVE      FALSE,EXIT
.
          GOTO      B1SL9999
.
.------ something other than a number has been entered ------
.
B1SL3000  REP       UPPLOW,DIM2
          REP       "E1S2P3",DIM2
          MOVE      ZERO,FORM1
          MOVE      DIM2,FORM1
.
          BRANCH    FORM1,B1SL4000,B1SL5000,B1SL6000
.                           Exit     Send     Prev
.
          GOTO      B1SL9000
.
.------ Exit has been chosen ------
.
B1SL4000  CALL      EQST0000                * Question if Ok. to Exit
          BRANCH    EXIT,B1SL0000           * No Answered.
.
          MOVE      TRUE,EXIT
.
          GOTO      B1SL9999
.
.------ It is O.K. to send the letters ------
.
B1SL5000  MOVE      TWO,EXIT
.
          GOTO      B1SL9999
.
.------ Previous screen has been chosen ------
.
B1SL6000  COMPARE   ONE,SCRNNUMB
          GOTO      B1SL9000 IF EQUAL
.
          MOVE      THREE,EXIT
.
          GOTO      B1SL9999
.
.------ invalid option ------
.
B1SL9000  BEEP
          GOTO      B1SL2000
.
B1SL9999  RETURN
+
.********************************************************************** 
.*                            B2SL0000                                *
.*                    Batch Screen Select Routine                     *
.*                     Used When Screen is Full                       *
.*                                                                    *
.*  Called By :                                                       *
.*                                                                    *
.*  Exit  0 = Valid Record to Delete                                  *
.*        1 = Exit                                                    *
.*        2 = Send the Letter                                         *
.*        3 = Next Screen                                             *
.*        4 = Previous Screen                                         *
.*                                                                    *
.********************************************************************** 
B2SL0000  MOVE      TWO,SELFLAG
.
          BRANCH    SCRNNUMB,B2SL1000       * skip if we are on the first 
.                                             screen
          DISPLAY   *P1:24,"Select Item to Delete, ":
                           "(",*V2LON,ANSE,*HOFF,")xit, ":
                           "(",*V2LON,ANSS,*HOFF,")end Letter, ":
                           "(",*V2LON,ANSN,*HOFF,")ext, ":
                           "(",*V2LON,ANSP,*HOFF,")revious ? "
.
          MOVE      SIXTY8,CCOL
.
          GOTO      B2SL2000
.
.------ we are on the first screen ------
.
B2SL1000  DISPLAY   *P1:24,"Select Item to Delete, ":
                           "(",*V2LON,ANSE,*HOFF,")xit, ":
                           "(",*V2LON,ANSS,*HOFF,")end Letter, ":
                           "(",*V2LON,ANSN,*HOFF,")ext ? "
.
          MOVE      FIFTY6,CCOL
.
.------ keyin an option ------
.
B2SL2000  KEYIN     *PCCOL:24,*EL,*DV,UNDLN2,*PCCOL:24,*V2LON,*JR,DIM2;
.
          TYPE      DIM2                    * see if a number was entered
          GOTO      B2SL3000 IF NOT EQUAL
.
          MOVE      DIM2,FORM2
.
          COMPARE   ONE,FORM2               * make sure a valid record has been
          GOTO      B2SL9000 IF LESS          selected
.
          COMPARE   FORM2,TEN8              * make sure a valid record has been
          GOTO      B2SL9000 IF LESS          selected
.
          MOVE      FALSE,EXIT
.
          GOTO      B2SL9999
.
.------ something other than a number has been selected ------
.
B2SL3000  REP       UPPLOW,DIM2
          REP       "E1S2P3N4",DIM2
          MOVE      ZERO,FORM1
          MOVE      DIM2,FORM1
          BRANCH    FORM1,B2SL4000,B2SL5000,B2SL6000,B2SL7000
.                           Exit     Send     Prev     Next
.
          GOTO      B2SL9000
.
.------ Exit has been chosen ------
.
B2SL4000  CALL      EQST0000                * Question if Ok. to Exit
          BRANCH    EXIT,B2SL0000           * No Answered.
.
          MOVE      TRUE,EXIT
.
          GOTO      B2SL9999
.
.------ Send has been chosen ------
.
B2SL5000  MOVE      TWO,EXIT
.
          GOTO      B2SL9999
.
.------ pervious screen has been chosen so see if we are on the first ------
.------ screen -------
.
B2SL6000  COMPARE   ONE,SCRNNUMB
          GOTO      B2SL9000 IF EQUAL
.
          MOVE      THREE,EXIT
.
          GOTO      B2SL9999
.
.------ Next has been chosen ------
.
B2SL7000  MOVE      FOUR,EXIT
.
          GOTO      B2SL9999
.
.------ invalid option ------
.
B2SL9000  BEEP
          GOTO      B2SL2000
.
B2SL9999  RETURN
+
.********************************************************************** 
.*                            EQST0000                                *
.*                         Exit  Question                             *
.********************************************************************** 
EQST0000  DISPLAY   *P1:24,*EL,"Are you sure you don't want to send any ":
                               "letters to these patients (":
                               *V2LON,ANSY,*HOFF,"/":
                               *V2LON,ANSN,*HOFF,") ? ";
.
.------ keyin answer ------
.
EQST1000  KEYIN     *P75:24,*EL,*DV,UNDLN1,*P75:24,*V2LON,ANS;
.
          ENDSET     ANS
          APPEND     SP1,ANS
          RESET      ANS
          REP        UPPLOW,ANS
.
          MATCH      SP1,ANS                * see if anything was entered 
          GOTO       EQST9000 IF EQUAL
.
          REP        "Y1N2",ANS
          MOVE       ZERO,FORM1
          MOVE       ANS,FORM1
          BRANCH     FORM1,EQST9700,EQST9500
.
.------ invalid option ------
.
EQST9000  BEEP
          GOTO      EQST1000
.
.------ No was entered ------
.
EQST9500  MOVE      TRUE,EXIT
.
          GOTO      EQST9999
.
.------ Yes was entered ------
.
EQST9700  MOVE      FALSE,EXIT
.
EQST9999  RETURN
+
.********************************************************************** 
.*                            DELT0000                                *
.*               Delete the Debtor Number Selected                    *
.*                                                                    *
.*  Exit  0 = Redisplay From Top of File                              *
.*        1 = No records left in File                                 *
.*        2 = Dont want to Delete                                     *
.*                                                                    *
.********************************************************************** 
DELT0000  DISPLAY   *P1:24,*EL,"Are you sure you don't want to send a ":
                               "letter to this patient (":
                               *V2LON,ANSY,*HOFF,"/":
                               *V2LON,ANSN,*HOFF,") ? ";
.
.------ keyin answer ------
.
DELT1000  KEYIN     *P70:24,*EL,*DV,UNDLN1,*P70:24,*V2LON,ANS;
.
          ENDSET    ANS
          APPEND    SP1,ANS
          RESET     ANS
          REP       UPPLOW,ANS
.
          MATCH     SP1,ANS                 * see if anything was entered
          GOTO      DELT2000 IF EQUAL
.
          REP       "Y1N2",ANS
          MOVE      ZERO,FORM1
          MOVE      ANS,FORM1
          BRANCH    FORM1,DELT3000,DELT9500
.
.------ invalid option ------
.
DELT2000  BEEP
          GOTO      DELT1000
.
.------ O.K. to delete so get the relevant key ------
.
DELT3000  LOAD      KEY18,FORM2,KEYST1,KEYST2,KEYST3:
                                KEYST4,KEYST5,KEYST6:
                                KEYST7,KEYST8,KEYST9:
                                KEYST10,KEYST11,KEYST12:
                                KEYST13,KEYST14,KEYST15:
                                KEYST16,KEYST17,KEYST18
.
          CALL      DETMPR1                 * delete from the temp file
.
          MOVE      SP20,KEY18
          CALL      RSTMPR1                 * see if any records on the
          CALL      RKTMPR1                   temp file
          BRANCH    OVRCD,DELT9000
.
          MOVE      KEYST1,KEY18            * Check for last record on page
          CALL      RDTMPR1
.
          COMPARE   ZERO,OVRCD
          GOTO      DELT4000 IF EQUAL
.
          CALL      RKTMPR1                 * see if next record exists
.
          COMPARE   ZERO,OVRCD
          GOTO      DELT4000 IF EQUAL
.
          CALL      PREV0000                * Go Back One Page
.
.------ position on the previous record for re-display ------
.
DELT4000  MOVE      KEYST1,KEY18
          CALL      RSTMPR1
          CALL      RPTMPR1
.
          DISPLAY   *P1:5,*EF;
.
          CALL      CLKY0000                * clear the key variables
.
          MOVE      ONE,RECNUMB
          MOVE      FIVE,SCRNPOS
          MOVE      FALSE,EXIT
.
          GOTO      DELT9999
.
.------ there are no records left on the temp file ------
.
DELT9000  MOVE      TRUE,EXIT
.
          GOTO      DELT9999
.
.------ it is not O.K. to delete this patient ------
.
DELT9500  MOVE      TWO,EXIT
.
DELT9999  RETURN
+
.********************************************************************** 
.*                            SEND0000                                *
.*                    Send Letter to Patients                         *
.********************************************************************** 
SEND0000  CALL      LETT0000                * Keyin Letter Number to Send
          BRANCH    EXIT,SEND9000
.
          CALL      CONTQST                 * Ok to Continue (Y/N/C) ?
          BRANCH    CEXIT,SEND1000,SEND0000,SEND8000
.
.------ It is O.K. to continue ------
.
SEND1000  CALL      DATE0000                * Keyin Letter Date
          BRANCH    EXIT,SEND8000
.
          CALL      PRNT0000                * Print Patient Letters
.
.------ restore the screen ------
.
SEND8000  CALL      PUTSCR00
.
          MOVE      TWO,EXIT
.
          GOTO      SEND9999
.
.------ no letter has been chosen ------
.
SEND9000  MOVE      TRUE,EXIT
.
          GOTO      SEND9999
.
SEND9999  RETURN
+
.********************************************************************** 
.*                            LETT0000                                *
.*                 Keyin Letter Number to be Sent                     *
.********************************************************************** 
LETT0000  MOVE      TRUE,QUESTFLG
.
.------ display letter number prompt ------
.
LETT0500  DISPLAY   *P1:23,*EF:
                    *P1:24,"Letter Number : ";
.
.------ keyin the letter number ------
.
LETT1000  KEYIN     *P17:24,*DV,UNDLN3,*P17:24,*V2LON,*JR,TEMPLETT;
.
          ENDSET    TEMPLETT
          APPEND    SP3,TEMPLETT
          RESET     TEMPLETT
.
          MATCH     SP3,TEMPLETT            * see if anything was entered
          GOTO      LETT9000 IF EQUAL
.
          MATCH     "  ?",TEMPLETT          * see if ? was entered
          GOTO      LETT5000 IF EQUAL
.
          TYPE      TEMPLETT                * skip if a number was not entered
          GOTO      LETT8000 IF NOT EQUAL
.
          PACK      KEY6,TEMPLETT,SP2,ZERO  
          CALL      RDPRLE1                 * read the letter file
          BRANCH    OVRCD,LETT8100
.
          MOVE      TEMPLETT,LETTFORM
.
          BRANCH    QUESTFLG,LETT2000       * skip if ? has not been entered
.
          CALL      PUTSCR00                * restore the screen
.
.------ display the letter details ------
.
LETT2000  DISPLAY   *P1:23,*EL,"Letter : ",*V2LON,PRLETEXT;
.
          MOVE      FALSE,EXIT
.
          GOTO      LETT9999
.
.------ ? has been entered ------
.
LETT5000  CALL      LETQ0000                * Letter Code Question Mark Option
.
          GOTO      LETT0500
.
.------ invalid letter chosen ------
.
LETT8000  BEEP
          GOTO      LETT1000
.
.------ letter not on file ------
.
LETT8100  DISPLAY   *P1:24,*EL,*B,"Letter Not on File - Hit <":
                               *V2LON,"ENTER",*HOFF,"> to Continue ";
          KEYIN     *EOFF,ANS;
          DISPLAY   *P1:24,*EL;
.
          GOTO      LETT0500
.
.------ no letter was entered ------
.
LETT9000  MOVE      TRUE,EXIT
.
          BRANCH    QUESTFLG,LETT9999       * skip if ? was not input
.
          CALL      FRESCR00                * free the current screen
.
LETT9999  RETURN
+
.**********************************************************************
.*                            LETQ0000                                *
.*               Question Mark Option for Letter File                 *
.**********************************************************************
LETQ0000  COMPARE   TRUE,QUESTFLG           * don't bother about saving the 
          GOTO      LETQ0500 IF NOT EQUAL     screen if we have already done a
.                                             ?
          MOVE      FALSE,QUESTFLG
.
          DISPLAY   *P17:24,UNDLN3;
.
          CALL      GETSCR00                * save the screen
.
.------ display the header for the ? option ------
.
LETQ0500  DISPLAY   *P1:4,*EF,*P30:4,*V2LON,*ULON,"EXISTING LETTERS"
          MOVE      FIVE,CVERT
          MOVE      ONE,CCOL
.
          MOVE      SP6,KEY6
          CALL      RSPRLE2                 * position on the letter file
.
.------ read through the letter file ------
.
LETQ1000  CALL      RKPRLE2
          BRANCH    OVRCD,LETQ2000
.
          COMPARE   ZERO,PRLELINE           * skip if we no longer have a 
          GOTO      LETQ9999 IF NOT EQUAL     header record
.
          MOVE      PRLETEXT,DIM30
          DISPLAY   *PCCOL:CVERT,*V2LON,PRLENUMB,SP2,*HOFF,DIM30;
          ADD       ONE,CVERT
.
          COMPARE   TWENTY3,CVERT           * see if the screen is full
          GOTO      LETQ1000 IF LESS
.
          MOVE      FIVE,CVERT
          ADD       "40",CCOL
          COMPARE   "70",CCOL
          GOTO      LETQ1000 IF LESS
.
          KEYIN     *P1:24,*EL," (",*V2LON,"C",*HOFF,")ontinue, (":
                    *V2LON,"N",*HOFF,")ext Screen : ",*V2LON,ANS;
.
          CMATCH    ANSC,ANS                * see if Continue was selected
          GOTO      LETQ9999 IF EQUAL
.
          MOVE      FIVE,CVERT
          MOVE      ONE,CCOL
          DISPLAY   *P1:5,*EF
.
          GOTO      LETQ1000
.
.------ no records on the letter file ------
.
LETQ2000  DISPLAY   *P1:24,*EF,"No Records Entered in Letter File - Hit <":
                    *V2LON,"ENTER",*HOFF,"> to Continue ";
          KEYIN     ANS;
.
LETQ9999  RETURN
.
.********************************************************************** 
.*                            DATE0000                                *
.*                     Keyin the Letter's Date                        *
.********************************************************************** 
DATE0000  DISPLAY   *P1:23,*EF:
                    *P1:24,"Enter the Date for the letter : "
.
          MOVE      CDD,CDAY
          REP       " 0",CDAY
          MOVE      CMM,CMON
          REP       " 0",CMON
          MOVE      CYY,CYEAR
          REP       " 0",CYEAR
          MOVE      CCC,CCENT
          REP       " 0",CCENT
          MOVE      THIRTY3,CCOL
          MOVE      TWENTY4,CVERT
          MOVE      ONE,CCANLDTE
          MOVE      ONE,CDEFDTE
          MOVE      ZERO,CHIGHLT
.
.------ keyin the date ------
.
DATE1000  CALL      KEYDATE
.
          CALL      PACDATE
          MOVE      CPCDATE,LETTDATE
          REP       " 0",LETTDATE
.
          BRANCH    OVRCD,DATE8000          * skip if no date was entered
          BRANCH    CQUEST,DATE1000
.
.------ see if we have a value for the day ------
.
DATE8000  MATCH     SP2,CDAY
          GOTO      DATE9000 IF NOT EQUAL
.
          MOVE      TRUE,EXIT
.
          GOTO      DATE9999
.
.------ we have a date ------
.
DATE9000  MOVE      FALSE,EXIT
.
DATE9999  RETURN
+
.********************************************************************** 
.*                            PRNT0000                                *
.*                      Print Patient Letters                         *
.********************************************************************** 
PRNT0000  DISPLAY   *P1:24,*EL,"Processing Debtor : ";
          CALL      CONS0000                * Set Up the Constant % Variables
          MOVE      ZERO,COUNTER
.
          MOVE      SP20,KEY18
          CALL      RSTMPR1                 * position on the temp file
.
.------ read through the temp file ------
.
PRNT1000  CALL      RKTMPR1
          BRANCH    OVRCD,PRNT9999
.
          DISPLAY   *P21:24,*V2LON,TMPDEBT;
.
          CALL      SET0000                 * Set up the Actual % Variables
          BRANCH    EXIT,PRNT1000
.
          ADD       ONE,COUNTER
          CALL      PRLT0000                * Print the Actual Letter
          GOTO      PRNT1000
.
PRNT9999  RETURN
+
.**********************************************************************
.*                            PRNW0000                                *
.*                  Print Patient Letters for Web                     *
.**********************************************************************
PRNW0000  DISPLAY   *P1:24,*EL,"Processing Debtor : ";
.
          CALL      CONS0000                * Set Up the Constant % Variables
.
          MOVE      ZERO,COUNTER
.
          PACK      KEY22,SELECTID,SP20
          CALL      RSPRGSL1                * position on the temp file
.
.------ read through the temp file ------
.
PRNW1000  CALL      RKPRGSL1
          BRANCH    OVRCD,PRNW9999
.
          MATCH     SELECTID,PRGSSEID
          GOTO      PRNW9999 IF NOT EQUAL
.
          MATCH     "1",PRGSSTAT            * Skip if status is deleted
          GOTO      PRNW1000 IF EQUAL
.
          MOVE      PRGSDEBT,TMPDEBT
          MOVE      PRGSSCAN,TMPSCAN
          MOVE      PRGSUNIQ,TMPUNIQ
          MOVE      PRGSPRAC,TMPPRAC
          MOVE      PRGSSDOC,TMPSDOC
          MOVE      PRGSPIND,TMPPIND
.
          CALL      SET0000                 * Set up the Actual % Variables
.
          BRANCH    EXIT,PRNW1000
.
          ADD       ONE,COUNTER
.
          CALL      PRLT0000                * Print the Actual Letter
          GOTO      PRNW1000
.
PRNW9999  RETURN
.
.********************************************************************** 
.*                            CONS0000                                *
.*                    Set Up Constant % Variables                     *
.********************************************************************** 
CONS0000  OPEN      CONTROLF,"controlf"
          READ      CONTROLF,THIRTY4;*2,PRCNADD1,PRCNADD2,PRCNADD3,PRCNPOST
          MOVE      CNAME,LXHOSP
          MOVE      PRCNADD1,LXHADDA
          MOVE      PRCNADD2,LXHADDB
          MOVE      PRCNADD3,LXHADDC
          MOVE      PRCNPOST,LXHPOST
          CLOSE     CONTROLF
.
          PACK      KEY8,CCC,CYY,CMM,CDD
          REP       " 0",KEY8
          UNPACK    KEY8,CCENT,CYEAR,CMON,CDAY  * current date
          CALL      FDAT0000                * format the date
          MOVE      DATELINE,LXDATE
.
CONS9999  RETURN
+
.**********************************************************************
.*                           FDAT0000                                 *
.*        Routine to format the date into variable DATELINE.          *
.*        Requires : CDAY, CMON, CYEAR, CCENT                         *
.**********************************************************************
FDAT0000  CLEAR     DATELINE                * initialise DATELINE
.
          MATCH     SP2,CDAY                * test day for spaces
          GOTO      FDAT7000 IF EQUAL
.
          MATCH     "99",CDAY               * test day for "99"
          GOTO      FDAT7000 IF EQUAL
.
          MOVE      CDAY,FORM2
.
.------ add date extension onto the day ------
.
          LOAD      DEXT,FORM2,DEXT1,DEXT2,DEXT3,DEXT4,DEXT4,DEXT4,DEXT4:
                    DEXT4,DEXT4,DEXT4,DEXT4,DEXT4,DEXT4,DEXT4:
                    DEXT4,DEXT4,DEXT4,DEXT4,DEXT4,DEXT4,DEXT1:
                    DEXT2,DEXT3,DEXT4,DEXT4,DEXT4,DEXT4,DEXT4:
                    DEXT4,DEXT4,DEXT1
.
          MOVE      CMON,FORM2
.
.------ change month into long format ------
.
          LOAD      MONTH,FORM2,MONTH1,MONTH2,MONTH3,MONTH4,MONTH5,MONTH6:
                    MONTH7,MONTH8,MONTH9,MONTH10,MONTH11,MONTH12
          RESET     CDAY
.
          CMATCH    "0",CDAY                * test if first character of CDAY
          GOTO      FDAT1000 IF NOT EQUAL     is zero
.
          BUMP      CDAY                    * remove first char if it is
.
.------ pack the formatted date ------
.
FDAT1000  PACK      DATELINE,CDAY,DEXT,SP1,MONTH,SP1,CCENT,CYEAR
          MOVE      DATELINE,LINE
          CALL      COMP0000                * compress multiple blanks
          MOVE      LINE,DATELINE
          GOTO      FDAT9999
.
.------ date does not exist ------
.
FDAT7000  MOVE      "99th December 1999",DATELINE
.
FDAT9999  RETURN
+
.**********************************************************************
.*                              COMP0000                              *
.*       Routine to compress excessive blanks in LINE                 *
.*       i.e. all leading, trailing and multiple blanks from in       *
.*       between words                                                *
.**********************************************************************
COMP0000  MOVE      LINE,DIM55
          PACK      TEMP55,SP20,SP20,SP10,SP5
.
          MATCH     TEMP55,DIM55            * test line for spaces
          GOTO      COMP9999 IF EQUAL
.
          CLEAR     LINE                    * reset LINE variable
.
.------ Compress all leading blanks ------
.
COMP1000  CMATCH    SP1,DIM55
          GOTO      COMP5000 IF NOT EQUAL   * compress leading blanks
.
          BUMP      DIM55                   * get next character 
          GOTO      COMP1000 IF NOT EOS       if not end of string
.
          GOTO      COMP8000
.
.------ Set up working variable with the new form pointer position ------
.
COMP5000  MOVE      DIM55,DIM55
          ENDSET    DIM55
.
.------ Compress all trailing blanks ------
.
COMP5100  CMATCH    SP1,DIM55               * remove trailing blanks until a 
          GOTO      COMP7000 IF NOT EQUAL     non blank character is found
.
          BUMP      DIM55,-1
          GOTO      COMP5100
.
.------ Position the form and logical length pointers ------
.
COMP7000  LENSET    DIM55
          RESET     DIM55
.
.------ Compress multiple blanks from in between words ------
.
COMP7100  MOVE      DIM55,ANS               * append first char to LINE
          APPEND    ANS,LINE                  as we know it is non blank
.
          BUMP      DIM55                   * skip over each character
          GOTO      COMP8000 IF EOS           until end of string is found
.
          CMATCH    SP1,DIM55               * get next character if not a space
          GOTO      COMP7100 IF NOT EQUAL
.
          MOVE      DIM55,ANS               * if space found we append it
          APPEND    ANS,LINE                  to LINE
.
.------ Bump over all extra spaces found ------
.
COMP7200  BUMP      DIM55
.
          CMATCH    SP1,DIM55               * bump over extra spaces until
          GOTO      COMP7100 IF NOT EQUAL     we find a non blank
.
          GOTO      COMP7200
.
.------ End of string found so reset LINE ------
.
COMP8000  RESET     LINE
          GOTO      COMP9999
.
COMP9999  RETURN
+
.********************************************************************** 
.*                            SET0000                                 *
.*                      Set the % Variables                           *
.********************************************************************** 
SET0000   CALL      FILL0000                * Fill % Var's with *'s
          BRANCH    TMPSCAN,SET0100         * skip if we have a U/R number
.
...          MOVE      TMPDEBT,KEY8
...          CALL      RDPRDB1                 * read the debtor file
...          BRANCH    OVRCD,SET9000
.
...          MOVE      PRDBADD1,LXADDA
...          MOVE      PRDBADD2,LXADDB
...          MOVE      PRDBADD3,LXADDC
...          MOVE      PRDBGNAM,LXFRSTI
...          MOVE      PRDBGNAM,LXGNAME
...          MOVE      PRDBSNAM,LXSNAME
...          MOVE      PRDBTITL,LXTITLE
...          MOVE      PRDBSNAM,PACSNAME
...          MOVE      PRDBGNAM,PACGNAME
...          MOVE      PRDBTITL,PACTITLE
...          MOVE      ONE,PACFRMT
.
...          CALL      PACNAME                 * pack the patients name
.
          MOVE      "Unknown Debtor Number",PACFNAME
          PACK      PACFNAME,PACFNAME,SP70
          MOVE      PACFNAME,LXFNAME
...          MOVE      PRDBMEMN,LXHFMEM
...          MOVE      PRDBTABL,LXHFTAB
...          MOVE      PRDBFUND,LXHFUND
...          MOVE      PRDBTELP,LXHTELE
...          MOVE      PRDBTELB,LXWTELE
...          MOVE      PRDBMEDN,LXMEDNO
...          MOVE      PRDBPOST,LXPCODE
.
          GOTO      SET0200
.
.------ we have a U/R number ------
.
SET0100   MOVE      TMPDEBT,PURNO
          MOVE      PURNO,KEY8
          CALL      RDMAST1                 * read the patient master file
          BRANCH    OVRCD,SET9100
.
          MOVE      PURNO,KEY8
          CALL      RDPMPX21                 * read the patient ext 2
          BRANCH    OVRCD,SET9100
.
          MOVE      PADD1,LXADDA
          MOVE      PADD2,LXADDB
          MOVE      PSUBRB,LXADDC
          MOVE      PGNAME,LXFRSTI
          MOVE      PGNAME,LXGNAME
          MOVE      PSNAME,LXSNAME
          MOVE      PTITL,LXTITLE
          MOVE      PSNAME,PACSNAME
          MOVE      PGNAME,PACGNAME
          MOVE      PTITL,PACTITLE
          MOVE      ONE,PACFRMT
.
          CALL      PACNAME                 * pack the patients name
.
          MOVE      PACFNAME,LXFNAME
          MOVE      PFNDMM,LXHFMEM
          MOVE      PFNDTB,LXHFTAB
          MOVE      PFUNDH,LXHFUND
          MOVE      PTELEP,LXHTELE
          MOVE      PTELEB,LXWTELE
          MOVE      PMEDI,LXMEDNO
          MOVE      PPOST,LXPCODE
.
          MOVE      PMPXSN18,LXPXSN18
          MOVE      PMPXSN19,LXPXSN19
          MOVE      PMPXSN20,LXPXSN20
          MOVE      PMPXSN21,LXPXSN21
          MOVE      PMPXSN22,LXPXSN22
          MOVE      PMPXSN23,LXPXSN23
          MOVE      PMPXSN24,LXPXSN24
          MOVE      PMPXSN25,LXPXSN25
          MOVE      PMPXSN26,LXPXSN26
          MOVE      PMPXSN27,LXPXSN27
          MOVE      PMPXSN28,LXPXSN28
          MOVE      PMPXSN29,LXPXSN29
          MOVE      PMPXSN30,LXPXSN30
.
.------ read the header file ------
.
SET0200   MOVE      TMPUNIQ,KEY8
          CALL      RDPRHD2
          BRANCH    OVRCD,SET9200
.
          PACK      KEY27,TMPUNIQ,TMPPRAC,TMPSDOC,TMPPIND
          CALL      RDPRHR1                 * read the referral file
          BRANCH    OVRCD,SET9300
.
. -----   LXACDATE  Accident Date   -----
.
          UNPACK    PRHDACCD,CCENT,CYEAR,CMON,CDAY
          CALL      PACDATE                 * pack the date
          MOVE      CPCDATE,LXACDATE
.
. -----   LXACLASS  Admission Class   -----
.
...          MATCH     SP3,PRDBADMN            * see if we have an admission class
...          GOTO      SET0300 IF EQUAL
.
...          PACK      KEY5,CODEGA,PRDBADMN
...          CALL      RDCODE1                 * read the patient codes file
...          BRANCH    OVRCD,SET0300
.
...          MOVE      TDESC,LXACLASS
.
. -----   LXCLMDES  Claim Description   -----
.
SET0300   MATCH     SP3,PRHDCLAM            * see if we have a claim code
          GOTO      SET0400 IF EQUAL
.
          PACK      KEY5,CODECL,PRHDCLAM
          CALL      RDCODE1                 * read the patient codes file
          BRANCH    OVRCD,SET0400
.
          MOVE      TDESC,LXCLMDES
.
. -----   LXDEBTNO  Debtor Number  ----
.
SET0400   MOVE      TMPDEBT,LXDEBTNO
.
. -----   LXDOB     Date of Birth  ----
.
...          UNPACK    PRDBDOBH,CCENT,CYEAR,CMON,CDAY
          UNPACK    PBDATE,CCENT,CYEAR,CMON,CDAY
          CALL      PACDATE                 * pack the date
          MOVE      CPCDATE,LXDOB
.
. -----   Debtor User Defineds   -----
.
...          MATCH     SP3,PRDBUDF1            * see if we have a user defined 
...          GOTO      SET0500 IF EQUAL          field
.
...          PACK      KEY5,CODEG5,PRDBUDF1
...          CALL      RDCODE1                 * read the patient codes file
...          BRANCH    OVRCD,SET0500
.
...          MOVE      TDESC,LXDUSR1
.
.------ see if the user defined field exists ------
. 
...SET0500   MATCH     SP3,PRDBUDF2            
...          GOTO      SET0600 IF EQUAL
.
...          PACK      KEY5,CODEG6,PRDBUDF2
...          CALL      RDCODE1                 * read the patient codes file
...          BRANCH    OVRCD,SET0600
.
...          MOVE      TDESC,LXDUSR2
.
.------ see if the user defined field exists ------
. 
...SET0600   MATCH     SP3,PRDBUDF3           
...          GOTO      SET0700 IF EQUAL
.
...          PACK      KEY5,CODEG7,PRDBUDF3
...          CALL      RDCODE1                 * read the patient codes file
...          BRANCH    OVRCD,SET0700
.
...          MOVE      TDESC,LXDUSR3
.
.------ see if the user defined field exists ------
. 
...SET0700   MATCH     SP3,PRDBUDF4          
...          GOTO      SET0800 IF EQUAL
.
...          PACK      KEY5,CODEG8,PRDBUDF4
...          CALL      RDCODE1                 * read the patient codes file
...          BRANCH    OVRCD,SET0800
.
...          MOVE      TDESC,LXDUSR4
.
.------ see if the practice exists ------
.
SET0800   MATCH     SP6,TMPPRAC
          GOTO      SET0900 IF EQUAL
.
          MOVE      TMPPRAC,KEY6
          CALL      RDPRPR1                 * read the practice file
          BRANCH    OVRCD,SET0900
.
          MOVE      PRPRDESC,LXPRADES
          MOVE      PRPRADD1,LXPRAADA
          MOVE      PRPRADD2,LXPRAADB
          MOVE      PRPRADD3,LXPRAADC
          MOVE      PRPRPOST,LXPRAPOS
          MOVE      PRPRTELP,LXPRATEL
.
.------ set up the responsible for account details ------
.
SET0900   MOVE      PRHRNAME,LXRESACC
          MOVE      PRHRADD1,LXRESADA
          MOVE      PRHRADD2,LXRESADB
          MOVE      PRHRADD3,LXRESADC
          MOVE      PRHRPOST,LXRESPCD
          MOVE      PRHRTELP,LXRESHTL
          MOVE      PRHRTELB,LXRESWTL
          MOVE      PRHRRELP,LXRESREL
.
. -----   Referring Doctor's details   -----
.
          IF        PRCNRDOC = 0
             PACK      KEY6,PRHRREFD
             PACK      KEY10,PRHRREFD,SP10
          ELSE
             PACK      KEY22,TMPUNIQ,ZEDS      * get last ref. doct for claim
             CALL      RSPRDT1
SET0950      CALL      RPPRDT1
             BRANCH    OVRCD,SET1000
.
             COMPARE   TMPUNIQ,PRDTUNIQ
             GOTO      SET1000 IF NOT EQUAL
.
             COMPARE   ONE,PRDTRTYP            * item transaction ?
             GOTO      SET0950 IF NOT EQUAL    * no
.
             MOVE      PRDTREFD,KEY6
             PACK      KEY10,PRDTREFD,SP10
          ENDIF
.
          CALL      RDPMHCP1                * read the doctor file
          BRANCH    OVRCD,SET1000
.
          MOVE      PMHCSNAM,PACSNAME
          MOVE      PMHCGNAM,PACGNAME
          MOVE      PMHCTITL,PACTITLE
          MOVE      "1",PACFRMT
.
          CALL      PACNAME                 * pack the name
.
          MOVE      PACFNAME,LXRDNAM
          MOVE      PMHCGNAM,LXRDFIN
          MOVE      PMHCGNAM,LXRDGIV
          MOVE      PMHCSNAM,LXRDSUR
          MOVE      PMHCTITL,LXRDTITL
.
. -----   Referral File User Defineds   -----
.
SET1000   MATCH     SP3,PRHRUDF1            * see if the user defined field
          GOTO      SET1100 IF EQUAL          exists
.
          PACK      KEY5,CODEG1,PRHRUDF1
          CALL      RDCODE1                 * read the patient codes file
          BRANCH    EXIT,SET1100
.
          MOVE      TDESC,LXRUSR1
.
.------ see if the user defined field exists ------
.
SET1100   MATCH     SP3,PRHRUDF2
          GOTO      SET1200 IF EQUAL
.
          PACK      KEY5,CODEG2,PRHRUDF2
          CALL      RDCODE1                 * read the patient codes file
          BRANCH    EXIT,SET1200
.
          MOVE      TDESC,LXRUSR2
.
.------ see if the user defined field exists ------
.
SET1200   MATCH     SP3,PRHRUDF3
          GOTO      SET1300 IF EQUAL
.
          PACK      KEY5,CODEG3,PRHRUDF3
          CALL      RDCODE1                 * read the patient codes file
          BRANCH    EXIT,SET1300
.
          MOVE      TDESC,LXRUSR3
.
.------ see if the user defined field exists ------
.
SET1300   MATCH     SP3,PRHRUDF4
          GOTO      SET1400 IF EQUAL
.
          PACK      KEY5,CODEG4,PRHRUDF4
          CALL      RDCODE1                 * read the patient codes file
          BRANCH    EXIT,SET1400
.
          MOVE      TDESC,LXRUSR4
.
. -----   Service Doctor's Details   -----
.
SET1400   PACK      KEY6,TMPSDOC
          PACK      KEY10,TMPSDOC,SP10
          CALL      RDPMHCP1                * read the doctor file
          BRANCH    OVRCD,SET1500
.
          MOVE      PMHCSNAM,PACSNAME
          MOVE      PMHCGNAM,PACGNAME
          MOVE      PMHCTITL,PACTITLE
          MOVE      "1",PACFRMT
.
          CALL      PACNAME                 * pack the name
.
          MOVE      PACFNAME,LXSERDOC
          MOVE      PMHCSNAM,LXSDSUR
          MOVE      PMHCGNAM,LXSDFIN
          MOVE      PMHCGNAM,LXSDGIV
          MOVE      PMHCTITL,LXSDTITL
.
. -----   LXVISDAT Visit Date   -----
.
SET1500   PACK      KEY62,TMPUNIQ,TMPPRAC,TMPSDOC,TMPPIND,SP30,SP30
          CALL      RSPRHT1                 * position on the transaction file
          CALL      RKPRHT1
          BRANCH    OVRCD,SET1600
.
          COMPARE   TMPUNIQ,PRHTUNIQ        * compare unique identifiers
          GOTO      SET1600 IF NOT EQUAL
.
          MATCH     TMPPRAC,PRHTPRAC        * match practices
          GOTO      SET1600 IF NOT EQUAL
.
          MATCH     TMPSDOC,PRHTDOCT        * match service doctors
          GOTO      SET1600 IF NOT EQUAL
.
          MATCH     TMPPIND,PRHTPIND        * match patient indicators
          GOTO      SET1600 IF NOT EQUAL
.
          UNPACK    PRHTDATE,CCENT,CYEAR,CMON,CDAY
          GOTO      SET1650
.
.------ position on the debtors transaction file ------
.
SET1600   PACK      KEY22,TMPUNIQ,SP20
          CALL      RSPRDT1
SET1620   CALL      RKPRDT1
          BRANCH    OVRCD,SET1700
.
          COMPARE   TMPUNIQ,PRDTUNIQ        * compare unique identifiers
          GOTO      SET1700 IF NOT EQUAL
.
          COMPARE   ONE,PRDTRTYP            * item transaction ?
          GOTO      SET1620 IF NOT EQUAL    * no
.
          UNPACK    PRDTSDAT,CCENT,CYEAR,CMON,CDAY
.
.------ pack the visit date ------
.
SET1650   CALL      PACDATE
          MOVE      CPCDATE,LXVISDAT
.
. -----   Case Conversion Section   -----
.
SET1700   MOVE      LXACLASS,LINE
          CALL      CASE0000
          MOVE      LINE,LXACLASS
.
          MOVE      LXADDA,LINE
          CALL      CASE0000
          MOVE      LINE,LXADDA
.
          MOVE      LXADDB,LINE
          CALL      CASE0000
          MOVE      LINE,LXADDB
.
          MOVE      LXADDC,LINE
          CALL      CASE0000
          MOVE      LINE,LXADDC
.
          MOVE      LXCLMDES,LINE
          CALL      CASE0000
          MOVE      LINE,LXCLMDES
.
          MOVE      LXDUSR1,LINE
          CALL      CASE0000
          MOVE      LINE,LXDUSR1
.
          MOVE      LXDUSR2,LINE
          CALL      CASE0000
          MOVE      LINE,LXDUSR2
.
          MOVE      LXDUSR3,LINE
          CALL      CASE0000
          MOVE      LINE,LXDUSR3
.
          MOVE      LXDUSR4,LINE
          CALL      CASE0000
          MOVE      LINE,LXDUSR4
.
          MOVE      LXFNAME,LINE
          CALL      CASE0000
          MOVE      LINE,LXFNAME
.
          MOVE      LXGNAME,LINE
          CALL      CASE0000
          MOVE      LINE,LXGNAME
.
          MOVE      LXHOSP,LINE
          CALL      CASE0000
          MOVE      LINE,LXHOSP
.
          MOVE      LXHADDA,LINE
          CALL      CASE0000
          MOVE      LINE,LXHADDA
.
          MOVE      LXHADDB,LINE
          CALL      CASE0000
          MOVE      LINE,LXHADDB
.
          MOVE      LXHADDC,LINE
          CALL      CASE0000
          MOVE      LINE,LXHADDC
.
          MOVE      LXPRADES,LINE
          CALL      CASE0000
          MOVE      LINE,LXPRADES
.
          MOVE      LXPRAADA,LINE
          CALL      CASE0000
          MOVE      LINE,LXPRAADA
.
          MOVE      LXPRAADB,LINE
          CALL      CASE0000
          MOVE      LINE,LXPRAADB
.
          MOVE      LXPRAADC,LINE
          CALL      CASE0000
          MOVE      LINE,LXPRAADC
.
          MOVE      LXRESACC,LINE
          CALL      CASE0000
          MOVE      LINE,LXRESACC
.
          MOVE      LXRESADA,LINE
          CALL      CASE0000
          MOVE      LINE,LXRESADA
.
          MOVE      LXRESADB,LINE
          CALL      CASE0000
          MOVE      LINE,LXRESADB
.
          MOVE      LXRESADC,LINE
          CALL      CASE0000
          MOVE      LINE,LXRESADC
.
          MOVE      LXRESREL,LINE
          CALL      CASE0000
          MOVE      LINE,LXRESREL
.
          MOVE      LXRDGIV,LINE
          CALL      CASE0000
          MOVE      LINE,LXRDGIV
.
          MOVE      LXRDNAM,LINE
          CALL      CASE0000
          MOVE      LINE,LXRDNAM
.
          MOVE      LXRDSUR,LINE
          CALL      CASE0000
          MOVE      LINE,LXRDSUR
.
          MOVE      LXRDTITL,LINE
          CALL      CASE0000
          MOVE      LINE,LXRDTITL
.
          MOVE      LXRUSR1,LINE
          CALL      CASE0000
          MOVE      LINE,LXRUSR1
.
          MOVE      LXRUSR2,LINE
          CALL      CASE0000
          MOVE      LINE,LXRUSR2
.
          MOVE      LXRUSR3,LINE
          CALL      CASE0000
          MOVE      LINE,LXRUSR3
.
          MOVE      LXRUSR4,LINE
          CALL      CASE0000
          MOVE      LINE,LXRUSR4
.
          MOVE      LXSDGIV,LINE
          CALL      CASE0000
          MOVE      LINE,LXSDGIV
.
          MOVE      LXSERDOC,LINE
          CALL      CASE0000
          MOVE      LINE,LXSERDOC
.
          MOVE      LXSDSUR,LINE
          CALL      CASE0000
          MOVE      LINE,LXSDSUR
.
          MOVE      LXSDTITL,LINE
          CALL      CASE0000
          MOVE      LINE,LXSDTITL
.
          MOVE      LXSNAME,LINE
          CALL      CASE0000
          MOVE      LINE,LXSNAME
.
          MOVE      LXTITLE,LINE
          CALL      CASE0000
          MOVE      LINE,LXTITLE
.
          MOVE      FALSE,EXIT
.
          GOTO      SET9999
.
.------ debtor record not on file ------
.
SET9000   DISPLAY   *P1:24,*EL,*B,"Debtor File Record Missing.  ";
          CALL      HITENTER
          GOTO      SET9900
.
.------ patient master record not on file ------
.
SET9100   DISPLAY   *P1:24,*EL,*B,"Master File Record Missing.  ";
          CALL      HITENTER
          GOTO      SET9900
.
.------ header record not on file ------
.
SET9200   DISPLAY   *P1:24,*EL,*B,"Holding Header File Record Missing.  ";
          CALL      HITENTER
          GOTO      SET9900
.
.------ referral record not on file ------
.
SET9300   DISPLAY   *P1:24,*EL,*B,"Holding Referral File Record Missing.  ";
          CALL      HITENTER
.
.------ set the Exit flag ------
.
SET9900   MOVE      TRUE,EXIT
.
SET9999   RETURN
+
.********************************************************************** 
.*                            FILL0000                                *
.*            Fill the Var's With *'s and 9's as appropriate          *
.********************************************************************** 
FILL0000  MOVE      "99/99/9999",LXACDATE
          MOVE      "********************",LXACLASS
          MOVE      "*************************",LXADDA
          MOVE      "*************************",LXADDB
          MOVE      "*************************",LXADDC
          MOVE      "********************",LXCLMDES
          MOVE      "********",LXDEBTNO
          MOVE      "99/99/9999",LXDOB
          MOVE      "********************",LXDUSR1
          MOVE      "********************",LXDUSR2
          MOVE      "********************",LXDUSR3
          MOVE      "********************",LXDUSR4
          MOVE      "*",LXFRSTI
          MOVE      STAR52,LXFNAME
          MOVE      "*************************",LXGNAME
          MOVE      "9999999999999999999",LXHFMEM
          MOVE      "********",LXHFTAB
          MOVE      "******",LXHFUND
          MOVE      "999999999999",LXHTELE
.>>>>>>>  MOVE      "99/99/9999",LXLETDAT
          MOVE      LETTDATE,LXLETDAT
          MOVE      "9999999999",LXMEDNO
          MOVE      "9999",LXPCODE
          MOVE      "******************************",LXPRADES
          MOVE      "*************************",LXPRAADA
          MOVE      "*************************",LXPRAADB
          MOVE      "*************************",LXPRAADC
          MOVE      "9999",LXPRAPOS
          MOVE      "************",LXPRATEL
          MOVE      STAR45,LXRESACC
          MOVE      "*************************",LXRESADA
          MOVE      "*************************",LXRESADB
          MOVE      "*************************",LXRESADC
          MOVE      "9999",LXRESPCD
          MOVE      "999999999999",LXRESHTL
          MOVE      "999999999999",LXRESWTL
          MOVE      "**********",LXRESREL
          MOVE      "*",LXRDFIN
          MOVE      "*************************",LXRDGIV 
          MOVE      STAR56,LXRDNAM
          MOVE      "********************",LXRDSUR
          MOVE      "*********",LXRDTITL
          MOVE      "********************",LXRUSR1
          MOVE      "********************",LXRUSR2
          MOVE      "********************",LXRUSR3
          MOVE      "********************",LXRUSR4
          MOVE      "*",LXSDFIN
          MOVE      "*************************",LXSDGIV 
          MOVE      STAR56,LXSERDOC
          MOVE      "********************",LXSDSUR
          MOVE      "*********",LXSDTITL
          MOVE      "********************",LXSNAME
          MOVE      "****",LXTITLE
          MOVE      "999999999999",LXWTELE
          MOVE      "99/99/9999",LXVISDAT
.
          MOVE      "*",LXPXSN18
          MOVE      "*",LXPXSN19
          MOVE      "*",LXPXSN20
          MOVE      "*",LXPXSN21
          MOVE      "*",LXPXSN22
          MOVE      "*",LXPXSN23
          MOVE      "*",LXPXSN24
          MOVE      "*",LXPXSN25
          MOVE      "*",LXPXSN26
          MOVE      "*",LXPXSN27
          MOVE      "*",LXPXSN28
          MOVE      "*",LXPXSN29
          MOVE      "*",LXPXSN30
.
FILL9999  RETURN
+
.**********************************************************************
.*                             CASE0000                               *
.*  Routine to convert all except first character of each word to     *
.*        lower case                                                  *
.**********************************************************************
CASE0000  MOVE      ONE,FIRSTCH
          RESET     LINE
.
.------ see if the current character is a space ------
.
CASE1000  CMATCH    SP1,LINE
          GOTO      CASE5000 IF EQUAL            * match char to space
.
          BRANCH    FIRSTCH,CASE2000             * skip if we have the first 
.                                                  character of a word
          MOVE      LINE,ANS
          RESET     UPPLOW
.
          SCAN      ANS,UPPLOW                   * test to see if char is
          GOTO      CASE1100 IF EQUAL              a letter
.
          MOVE      ONE,FIRSTCH
.
          GOTO      CASE3000                     * any char but a letter
.                                                  found
CASE1100  OR        040,LINE                     * actual conversion to
          RESET     UPPLOW                         lower case (believe it
.                                                              or not!)
.------ we are not on the first character any more ------
.
CASE2000  MOVE      ZERO,FIRSTCH
.                              
.------ get the next character to process ------
.
CASE3000  BUMP      LINE
          GOTO      CASE1000 IF NOT EOS          * move to next char
.
          RESET     LINE                         * end of line reached
.
          GOTO      CASE9999
.
.------ we have a space ------
.
CASE5000  MOVE      ONE,FIRSTCH                  * first char was a space
.
          GOTO      CASE3000
.
CASE9999  RETURN
+
.**********************************************************************
.*                  PRLT0000                                          *
.*             Set up and print letter one line at a time             *
.*        Returns : EXIT = 0      ask if to print more letters        *
.*                  EXIT = 1      select another letter to print      *
.*                  EXIT = 2      get next item on temp file          *
.**********************************************************************
PRLT0000  MOVE      FALSE,EXIT
          MOVE      ONE,COUNT               * line number to print
.
          MOVE      ZERO,FORM3              * read letter file header
          PACK      KEY6,LETTFORM,FORM3     *    record
          CALL      RDPRLE1
.
          MOVE      PRLEPLEN,PHYSPAGE
          MOVE      PRLEMTOP,TOPMARG
          MOVE      PRLEMBOT,BOTTMARG
          SUBTRACT  PRLEMBOT,PRLEPLEN
          MOVE      PRLEPLEN,MLETPLEN
          MOVE      PRLELEFT,LEFTMARG
.
.------ print top margin ------
.
PRLT0050  PRINT     *N;                     * print blank line
          COMPARE   COUNT,TOPMARG
          GOTO      PRLT1000 IF EQUAL       * printed top margin
.
          ADD       ONE,COUNT
          GOTO      PRLT0050
.
. ------- print letter one line at a time ------
.
PRLT1000  CALL      RKPRLE1
          BRANCH    OVRCD,PRLT9000          * end of letter reached
.
          COMPARE   LETTFORM,PRLENUMB
          GOTO      PRLT9000 IF NOT EQUAL   * different letter number
.
          BRANCH    PRLEVARB,PRLT2000       * have a % var
.
.         printing when no % variables
.
          PRINT     *N,*LEFTMARG,PRLETEXT;  * print text if no % vars
          ADD       ONE,COUNT
.
          COMPARE   COUNT,MLETPLEN
          CALL      PAGE0000 IF EQUAL       * print page when required
.
          GOTO      PRLT1000
.
.         printing when have % variables
.
PRLT2000  CALL      MOD0000                 * substitute % var value
.
          PRINT     *N,*LEFTMARG,PRTSTRNG;  * print text with % vars
          ADD       ONE,COUNT
.
          COMPARE   COUNT,MLETPLEN
          CALL      PAGE0000 IF EQUAL       * print page when required
.
          GOTO      PRLT1000
.
. ------- end of current letter reached -------
.
PRLT9000  COMPARE   TOPMARG,COUNT
          GOTO      PRLT9500 IF EQUAL       * no lines of text printed
.
          DISPLAY   *P60:24,*EL,*V2LON,COUNTER,*HOFF," Printed";
          MOVE      PHYSPAGE,TEMP3          * set up variables for
          SUBTRACT  COUNT,PHYSPAGE          *   paging
          MOVE      ONE,COUNT
.
.------ paginate at end of each letter ------
.
PRLT9100  PRINT     *N;
.
          COMPARE   COUNT,PHYSPAGE
          GOTO      PRLT9400 IF EQUAL       * printed bottom margin
.
          ADD       ONE,COUNT
          GOTO      PRLT9100
.
.------ we have reached the end of the current letter ------
.
PRLT9400  MOVE      TEMP3,PHYSPAGE          * restore physical page length
          MOVE      TWO,EXIT                * indicate to continue
          GOTO      PRLT9999
.
.------ letter header is on file but nothing else ------
.
PRLT9500  DISPLAY   *P1:24,*EL,*B,"Letter has not been set up yet - Hit <":
                    *V2LON,"ENTER",*HOFF,">";
          KEYIN     ANS;
          MOVE      TRUE,EXIT               * enter another letter code
.
PRLT9999  RETURN
+
.**********************************************************************
.*                              PAGE0000                              *
.*        Routine to paginate if a new page is required               *
.**********************************************************************
PAGE0000  MOVE      PRLENUMB,FORM3
          MOVE      PRLELINE,FORM3A
          CALL      RKPRLE1                       * get the next letter record
          BRANCH    OVRCD,PAGE8000
.
          COMPARE   LETTFORM,PRLENUMB             *  another line of the
          GOTO      PAGE8000 IF NOT EQUAL         *  letter exists
.
          MOVE      TOPMARG,TEMP2
          ADD       BOTTMARG,TOPMARG
          MOVE      ONE,COUNT
.
.------ loop to paginate ------
.
PAGE1000  PRINT     *N;
.
          COMPARE   COUNT,TOPMARG                * see if paginating is 
          GOTO      PAGE9000 IF EQUAL               complete
.
          ADD       ONE,COUNT
.
          GOTO      PAGE1000
.
.------ no need to paginate ------
.
PAGE8000  PACK      KEY6,FORM3,FORM3A
          CALL      RDPRLE1                       * read the letter file
.
          GOTO      PAGE9999
.
.------ reset read to previous record to continue processing ------
.
PAGE9000  MOVE      TEMP2,COUNT
          MOVE      TEMP2,TOPMARG
          PACK      KEY6,FORM3,FORM3A
          CALL      RDPRLE1                       * read the letter file
.
PAGE9999  RETURN
+
.**********************************************************************
.*                  MOD0000                     Called by : PRLT2000  *
.*             Modify a line to substitute "%" variable values        *
.**********************************************************************
MOD0000   MOVE      PRLETEXT,DIM70
          PACK      PRTSTRNG,SP30,SP30,SP10          * initialise PRTSTRNG
          RESET     PRTSTRNG,0                       *   and pointer positions
          MOVE      ONE,STARTSTR
          MOVE      ONE,ENDSTR
.
.------ get the next % variable if it exists ------
.
MOD2000   SCAN      SPECCHAR,DIM70                * Scan the Input Line for
          GOTO      MOD8000 IF NOT EQUAL          * a "%" sign
.
          MOVEFPTR  DIM70,PERCPOS
          BUMP      DIM70,-1                     * Go to the character before
.                                                * the "%" sign
          GOTO      MOD3100 IF NOT EOS            * Test if the % sign is the
          RESET     DIM70,0                      * first character on the line
.                                                * set f.p. to 0 if it is
MOD3100   MOVEFPTR  DIM70,ENDSTR                  * store endtsr at position
          COMPARE   STARTSTR,ENDSTR               *   1 char before the % sign
          GOTO      MOD3200 IF NOT LESS           *   and ensure that end and
.                                                *   start positions dont
.                                                *   overlap
          RESET     DIM70,STARTSTR                * set pointer to next % sign
          GOTO      MOD9999 IF EOS                *   if end < start
.
          GOTO      MOD3300
.
MOD3200   RESET     DIM70,STARTSTR                * reset the pointers to
          SETLPTR   DIM70,ENDSTR                  *   extract text preceding
          APPEND    DIM70,PRTSTRNG                *   the % sign
.
MOD3300   SETLPTR   DIM70,70                      * set the pointers to start at
          RESET     DIM70,PERCPOS                 *    % and go to position 70
          MOVE      DIM70,TEMP70                  * delete preceding text from
          MOVE      TEMP70,DIM70                  *    the DIM70 string
.
MOD4000   CALL      GETV0000                      * extract the % var
          MOVEFPTR  DIM70,STARTSTR                * store finish pos. of var
          BRANCH    EXIT,MOD5000
          RESET     SRCHVAR
.
.------ search for the % var in the list of constants ------
.
          SEARCH    SRCHVAR,LCACDATE,SEVENTY4,SRCHNUM
.
          COMPARE   TWENTY8,SRCHNUM
          GOTO      MOD7000 IF EQUAL        * Page Variable
.
MOD4500   COMPARE   ZERO,SRCHNUM                   * % var not found in list
          GOTO      MOD5000 IF EQUAL
.
.------ load DISPSTRN with the actual value of the % var ------
.
          LOAD      DISPSTRN,SRCHNUM,LXACDATE,LXACLASS,LXADDA,LXADDB,LXADDC:
                             LXCLMDES,LXDATE,LXDEBTNO,LXDOB,LXDUSR1:        *10 
                             LXDUSR2,LXDUSR3,LXDUSR4,LXFRSTI,LXFNAME:       *15 
                             LXGNAME,LXHFMEM,LXHFTAB,LXHFUND,LXHOSP:        *20
                             LXHADDA,LXHADDB,LXHADDC,LXHPOST,LXHTELE:       *25
                             LXLETDAT,LXMEDNO,LXPAGE,LXPCODE,LXPRADES:      *30
                             LXPRAADA,LXPRAADB,LXPRAADC,LXPRAPOS,LXPRATEL:  *35
                             LXRESACC,LXRESADA,LXRESADB,LXRESADC,LXRESPCD:  *40
                             LXRESHTL,LXRESWTL,LXRESREL,LXRDFIN,LXRDGIV:    *45
                             LXRDNAM,LXRDSUR,LXRDTITL,LXRUSR1,LXRUSR2:      *50
                             LXRUSR3,LXRUSR4,LXSDFIN,LXSDGIV,LXSERDOC:      *55
                             LXSDSUR,LXSDTITL,LXSNAME,LXTITLE,LXVISDAT:     *60
                             LXWTELE,LXPXSN18,LXPXSN19,LXPXSN20,LXPXSN21:   *65
                             LXPXSN22,LXPXSN23,LXPXSN24,LXPXSN25,LXPXSN26:  *70
                             LXPXSN27,LXPXSN28,LXPXSN29,LXPXSN30
.
          APPEND    DISPSTRN,PRTSTRNG
          CALL      COMX0000                   * compress trailing blanks in
          GOTO      MOD2000                    *    PRTSTRNG
.
MOD5000   RESET     SRCHVAR                    * add the string starting with
          APPEND    SRCHVAR,PRTSTRNG           *    a % if not found in the
          GOTO      MOD8000 IF EOS             *    list of constants
          GOTO      MOD2000
.
.------ %page variable found ------
.
MOD7000   MOVE      PHYSPAGE,TEMP3
          SUBTRACT  COUNT,PHYSPAGE
          MOVE      ONE,COUNT
          ADD       TOPMARG,PHYSPAGE
          SUBTRACT  ONE,PHYSPAGE
.
MOD7100   PRINT     *N;
          COMPARE   COUNT,PHYSPAGE
          GOTO      MOD7500 IF EQUAL
          ADD       ONE,COUNT
          GOTO      MOD7100
.
MOD7500   MOVE      TEMP3,PHYSPAGE
          MOVE      TOPMARG,COUNT
          SUBTRACT  ONE,COUNT
          PACK      PRTSTRNG,SP30,SP30,SP10
          GOTO      MOD9999
.
MOD8000   APPEND    DIM70,PRTSTRNG                    * add remaining text to
          RESET     PRTSTRNG                          *   PRTSTRNG if no %
.                                                     *   signs left
MOD9999   RETURN
+
.**********************************************************************
.*                              GETV0000                              *
.*           Extracts the "%" variable from the line                  *
.**********************************************************************
GETV0000  MOVE      FALSE,EXIT
          PACK      SRCHVAR,SP30,SP30,SP10
          RESET     SRCHVAR,0
          MOVE      DIM70,ANS
          APPEND    ANS,SRCHVAR
          RESET     SRCHVAR,0
          BUMP      DIM70
          MOVE      DIM70,ANS
          REPLACE   REPSTR,ANS                        * check to see if first
.
          MATCH     "0",ANS                           *   char after % is a
          GOTO      GETV9000 IF NOT EQUAL             *   lower case letter
.
          BUMP      DIM70,-1
          PACK      SRCHVAR,SP30,SP30,SP10            * initialise SRCHVAR
          RESET     SRCHVAR,0                         *   value and pointers
.
.------ append % var to SRCHVAR until anything but ------
.------ a lower case letter is found ------
.
GETV1000  MOVE      DIM70,ANS
          APPEND    ANS,SRCHVAR
.
          BUMP      DIM70
          GOTO      GETV9999 IF EOS
          MOVE      DIM70,ANS
          REPLACE   REPSTR,ANS
          MATCH     "0",ANS
          GOTO      GETV9999 IF NOT EQUAL
          GOTO      GETV1000
.
.------ string found is not a valid % var ------
.
GETV9000  MOVE      TRUE,EXIT
.
GETV9999  RETURN
+
.**********************************************************************
.*                              COMX0000                              *
.*         Routine to compress trailing blanks in PRTSTRNG            *
.**********************************************************************
COMX0000  ENDSET    PRTSTRNG
.
.------ see if current character is a space ------
.
COMX1000  CMATCH    SP1,PRTSTRNG
          GOTO      COMX9999 IF NOT EQUAL
.
          BUMP      PRTSTRNG,-1
          GOTO      COMX9999 IF EOS
.
          GOTO      COMX1000
.
COMX9999  RETURN
.
.------ I/O Routines for temp file ------
.
RATMPR1   MOVE      ZERO,OVRCD
          RESET     KEY18
          READ      PRITM1XX,KEY18;ANS
          GOTO      OVERCOND IF OVER
          RETURN
.
RSTMPR1   MOVE      ZERO,OVRCD
          RESET     KEY18
          READ      PRITM1XX,KEY18;;
          RETURN
.
RDTMPR1   MOVE      ZERO,OVRCD
          RESET     KEY18
          READ      PRITM1XX,KEY18;TMPDEBT,DTMPSCAN,DTMPUNIQ,TMPPRAC,TMPSDOC:
                                   TMPPIND
          GOTO      OVERCOND IF OVER
          MOVE      DTMPSCAN,TMPSCAN
          MOVE      DTMPUNIQ,TMPUNIQ
          RETURN
.
RKTMPR1   MOVE      ZERO,OVRCD
          RESET     KEY18
          READKS    PRITM1XX;TMPDEBT,DTMPSCAN,DTMPUNIQ,TMPPRAC,TMPSDOC:
                             TMPPIND
          GOTO      OVERCOND IF OVER
          MOVE      DTMPSCAN,TMPSCAN
          MOVE      DTMPUNIQ,TMPUNIQ
          RETURN
.
RPTMPR1   MOVE      ZERO,OVRCD
          RESET     KEY18
          READKP    PRITM1XX;TMPDEBT,DTMPSCAN,DTMPUNIQ,TMPPRAC,TMPSDOC:
                             TMPPIND
          GOTO      OVERCOND IF OVER
          MOVE      DTMPSCAN,TMPSCAN
          MOVE      DTMPUNIQ,TMPUNIQ
          RETURN
.
WRTMPR1   MOVE      ZERO,OVRCD
          RESET     KEY18
          WRITE     PRITM1XX,KEY18;KEY18,TMPPRAC,TMPSDOC,TMPPIND
          RETURN
.
UPTMPR1   MOVE      TMPSCAN,DTMPSCAN
          MOVE      TMPUNIQ,DTMPUNIQ
          UPDATE    PRITM1XX;TMPDEBT,DTMPSCAN,DTMPUNIQ,TMPPRAC,TMPSDOC:
                             TMPPIND
          RETURN
.
DETMPR1   RESET     KEY18
          DELETE    PRITM1XX,KEY18
          RETURN
.
OPEN0000
CLOS0000
GETSVAR   RETURN
.
          INC       STD001IO
.
          INC       PATCODKY
          INC       PATSNDX
          INC       PATSRCH
...          INC       PRIDBTDS
          INC       PRIKYDEB
          INC       PRIMPDKY                * Keyin the medical practice doctor
          INC       PRIPRADS
.
          INC       BOKRC1IO/INC
.
          INC       OUTPREIO/INC
.
          INC       PATCODIO/INC
          INC       PMSHCPIO/INC
          INC       PATGSRIO/INC
          INC       PATMA1IO/INC
          INC       PMSPX2IO/INC
          INC       PATMI1IO/INC
          INC       PMSVX1IO/INC
          INC       PATPR1IO/INC
...          INC       PRIDBTIO/INC
          INC       PRIDOCIO/INC
          INC       PRIDTRIO/INC
          INC       PRIHDBIO/INC
          INC       PRIHREIO/INC
          INC       PRIHTRIO/INC
          INC       PRIINVIO/INC
          INC       PRILETIO/INC
          INC       PRIPRAIO/INC
          INC       PRIGLSIO/INC
          INC       PRIGSLIO/INC
.
          INC       PATSNX2
          INC       NZIBSRCH
          INC       NZHISIIO
          INC       CLPATMAS
          INC       CALCAGE
          INC       NHIMASIO/INC                 * NZHIS Variables
.
